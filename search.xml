[{"title":"上传图片","url":"http://yoursite.com/2019/07/28/7-28/","content":"<h4 id=\"上传图片\"><a href=\"#上传图片\" class=\"headerlink\" title=\"上传图片\"></a>上传图片</h4><ol>\n<li><p>使<code>input[type=file]</code>只能上传图片类型的文件，在标签中设置<code>accept=&quot;image/*&quot;</code>，据说这样在Webkit内核的浏览器中会使打开文件夹的速度变慢，但是我在谷歌浏览器中试了一下，感觉速度差不多。不过还是记一下博主说的解决方法：<code>&lt;input type=&quot;file&quot; accept=&quot;image/gif,image/jpeg,image/jpg,image/png,image/svg&quot;&gt;</code>，即把<code>image/</code>后面的通配符改成具体的文件类型名。</p>\n<p>参考博文：<a href=\"https://www.cnblogs.com/java-dyb/p/10895077.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/java-dyb/p/10895077.html</a></p>\n</li>\n<li><p><code>input[type=file]</code>上传多个文件，设置<code>multiple</code>属性即可。</p>\n</li>\n<li><p><code>FileReader</code>对象的<code>readAsDataURL</code>方法</p>\n<p>学习上传一个或多个文件的过程中，参考了几篇博文，其中起作用最大的两篇：<a href=\"https://www.jianshu.com/p/57c8103272bf，https://www.cnblogs.com/web-wjg/p/7799173.html\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/57c8103272bf，https://www.cnblogs.com/web-wjg/p/7799173.html</a></p>\n<p>在上传并回显图片的函数中，使用了<code>FileReader</code>对象，下面是我根据自己的情况并参考博文写的函数（还没有完全完善），附上HTML和CSS代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"pic\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"add\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"file\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"pic_vid\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"pic_vid\"</span> <span class=\"attr\">multiple</span> <span class=\"attr\">accept</span>=<span class=\"string\">\"image/*\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.pic</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">92vw</span>;</span><br><span class=\"line\">    <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">    <span class=\"attribute\">right</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: auto;</span><br><span class=\"line\">    <span class=\"attribute\">margin-top</span>: <span class=\"number\">1vw</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.pic</span>&gt;<span class=\"selector-tag\">div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">25.6vw</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">25.6vw</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-size</span>: cover;</span><br><span class=\"line\">    <span class=\"attribute\">vertical-align</span>: middle;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">1vw</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.add</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-image</span>: <span class=\"built_in\">url</span>(../images/kaola/add.png);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.add</span>&gt;<span class=\"selector-tag\">input</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">outline</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">opacity</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 功能：读取图片</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">readPic</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//绑定change事件，.add选取的是上传文件按钮的盒子</span></span><br><span class=\"line\">    $(<span class=\"string\">\".add\"</span>).change(</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//#pic_vid是上传文件的input元素</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> files = $(<span class=\"string\">\"#pic_vid\"</span>)[<span class=\"number\">0</span>].files;</span><br><span class=\"line\">            <span class=\"comment\">//上传多个文件，获取文件个数</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> length = files.length;</span><br><span class=\"line\">            <span class=\"comment\">//遍历取得的文件，并一一添加至页面中</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; length; i++)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//新建FileReader对象</span></span><br><span class=\"line\">                <span class=\"keyword\">let</span> reader = <span class=\"keyword\">new</span> FileReader();</span><br><span class=\"line\">                reader.readAsDataURL(files[i]);</span><br><span class=\"line\">                <span class=\"comment\">//加载完成时触发</span></span><br><span class=\"line\">                reader.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//获取图片</span></span><br><span class=\"line\">                    <span class=\"keyword\">let</span> newUrl = <span class=\"keyword\">this</span>.result;</span><br><span class=\"line\">                    <span class=\"comment\">//创建新的放置图片元素</span></span><br><span class=\"line\">                    <span class=\"keyword\">let</span> newImg = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//将元素插入DOM树</span></span><br><span class=\"line\">                    $(<span class=\"string\">\".pic\"</span>).prepend(newImg);</span><br><span class=\"line\">                    <span class=\"comment\">//设置类名和背景图片（即想要上传的图片）</span></span><br><span class=\"line\">                    newImg.className = <span class=\"string\">\"new\"</span>;</span><br><span class=\"line\">                    newImg.style.backgroundImage = <span class=\"string\">\"url(\"</span> + newUrl + <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>里面很多我都能理解并加了注释，但是<code>reader.readAsDataURL(files[i]);</code>这一行我有些不能理解，这个语句并不赋值而且将它的位置放到<code>onload</code>之后也能正确运行，但是把它删掉就无法运行。</p>\n<p>我做了一个实验，在插入元素完成后加了一个弹出框的语句<code>alert(reader.readyState);</code>，</p>\n<p><img src=\"/2019/07/28/7-28/readPic_test.png\" alt></p>\n<p>发现在添加图片后，是先插入元素（此时图片还未显示出来），弹出输入框点击确认后，才显示出图片的样子。</p>\n<p><img src=\"/2019/07/28/7-28/test.png\" alt></p>\n<p><img src=\"/2019/07/28/7-28/test_3.png\" alt></p>\n<p>看一下上面的图片，可以发现在输入框弹出来的时候，<code>newImg</code>已经成功插入DOM树了，<code>class</code>属性也已设置好，但背景图片这个属性的设置并未起作用。</p>\n<p>只是为什么呢，观察一下<code>alert</code>语句之前的两行语句，看起来都是执行同一种类型的命令（为新增的元素添加属性），只是第一句奏效了但第二句好像是在<code>alert</code>之后才起作用。对比一下发现了在第二句中，有一个变量<code>newUrl</code>，那回到这个变量赋值的那一行<code>let newUrl = this.result;</code>（这里<code>this</code>指的是<code>reader</code>变量即<code>FileReader</code>的实例），设置背景图片的语句没有起作用是不是因为此时<code>newUrl</code>还没有完全获取到？难道<code>reader.readAsDataURL(files[i]);</code>的执行是异步的？</p>\n<p>我在Chrome的控制台的JavaScript文件中设置了断点，通过调试看了一下执行顺序，结果却是和之前观察到的有所不同，在断点调试中弹出框却是在图片显示之后才出现的。那这是怎么回事？</p>\n<p>想了一下决定转移一下目光，我想会不会是<code>alert</code>的问题，所以我搜索了<strong>alert()执行时间</strong>，找到了一篇博客感觉写的还不错：<a href=\"https://www.cnblogs.com/zhenbianshu/p/8686681.html。\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhenbianshu/p/8686681.html。</a></p>\n<p>这篇博文里讲到JavaScript的线程模型：单线程。也就是说只有一个线程在运行JavaScript程序，但是这样做的话如果遇到代码阻塞会影响到后面任务的执行。所以便有了事件循环（<code>event loop</code>）的产生，JavaScript将一些异步操作或有<code>I/O</code>阻塞的操作（我的理解就是比较花时间的操作）全都放到一个事件队列，先顺序执行同步CPU代码，等到这些代码执行完了CPU空闲下来之后，再读取事件列表的异步事件来依次执行。</p>\n<p>其中作者提到<strong><code>alert()</code> 是 window 的内置函数，被认为是同步 CPU代码；由于页面渲染是 DOM 操作，会被 JavaScript 引擎放入事件队列</strong>。这里我就大胆猜测，由于<code>reader.readAsDataURL(files[i]);</code>运行时间较长可能会造成时间阻塞，或者是设置背景图片这个属性涉及到页面渲染，所以被放进了事件队列，因此会在<code>alert</code>执行后再显示图片。那到底是前者的原因还是后者呢，我再来试一试。</p>\n<p>我把<code>newImg.style.backgroundImage = &quot;url(&quot; + newUrl + &quot;)&quot;;</code>一句中的<code>newUrl</code>替换成一个固定的图片地址，这样这个语句就与<code>reader.readAsDataURL(files[i]);</code>的执行无关，再次试验上传图片，发现和原来是一样的。</p>\n<p><img src=\"/2019/07/28/7-28/test_2.png\" alt></p>\n<p>这次还有个意外发现，是我上次实验没注意到的。就是图中红色箭头指向的地方，虽然我新创造的节点已经出现在DOM树中，但是页面上却一点影子都没有，这更说明和页面渲染是有关系的。通过这就可以确定插入新节点并渲染在页面上被放在了事件队列中，所以会在<code>alert</code>执行之后执行。</p>\n<p>那么<code>reader.readAsDataURL(files[i]);</code>会不会延后至行呢？其实这个问题在我之前找各种各样的答案时就得到了解决。下面是在MDN文档中看到的：</p>\n<p><img src=\"/2019/07/28/7-28/readAsDataURL.png\" alt></p>\n<p><img src=\"/2019/07/28/7-28/onload.png\" alt></p>\n<p>结合所写的代码可以知道，只有<code>reader.readAsDataURL(files[i]);</code>执行了，才会触动<code>reader.onload</code>的事件，并且结合之前测试用添加的<code>alert(reader.readyState);</code>，弹出来的总是2也可以得知已经读取完毕。</p>\n<p><img src=\"/2019/07/28/7-28/filereader_readystate.png\" alt></p>\n<p>前面文档中对<code>FileReader.readAsDataURL()</code>的解释也说了<strong>一旦完成，<code>result</code>属性中将包含一个<code>data:</code> URL格式的字符串以表示所读取文件的内容。</strong>也解了我对于这个方法的作用的疑惑。</p>\n<p>破案啦破案啦<del>撒花</del></p>\n</li>\n</ol>\n","categories":[],"tags":["日博"]},{"title":"移动端开发记录","url":"http://yoursite.com/2019/07/26/移动端开发记录/","content":"<ol>\n<li><p>iOS系统在点击元素触发事件时回事元素出现一瞬间的阴影，上网搜索之后发现了<code>-webkit-tap-highlight-color</code>这个属性，设置为透明度为0即可解决。</p>\n<p>参考网址：<a href=\"https://www.cnblogs.com/libin-1/p/5903350.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/libin-1/p/5903350.html</a></p>\n</li>\n<li><p>上传图片文件用到了<code>&lt;input type=&quot;file&quot;&gt;</code>这个标签，但是本身带有一些样式，想把原来的样式取消则设置<code>opacity: 0;</code>，另外想把点击输入框是外面那一圈高亮取消的话则设置<code>outline: 0;</code>。</p>\n</li>\n</ol>\n<ul>\n<li>题外话：今天的状态就很飘，学是不想学了停又不太敢停，呼！</li>\n</ul>\n","categories":[],"tags":["移动端"]},{"title":"jQyery_2","url":"http://yoursite.com/2019/07/25/jQyery-2/","content":"<p>今天继续学习jQuery</p>\n<ol>\n<li><p>看到添加元素的方法，里面菜鸟教程举了一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">appendText</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> txt1=<span class=\"string\">\"&lt;p&gt;文本。&lt;/p&gt;\"</span>;              <span class=\"comment\">// 使用 HTML 标签创建文本</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> txt2=$(<span class=\"string\">\"&lt;p&gt;&lt;/p&gt;\"</span>).text(<span class=\"string\">\"文本。\"</span>);  <span class=\"comment\">// 使用 jQuery 创建文本</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> txt3=<span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\">txt3.innerHTML=<span class=\"string\">\"文本。\"</span>;               <span class=\"comment\">// 使用 DOM 创建文本 text with DOM</span></span><br><span class=\"line\">$(<span class=\"string\">\"body\"</span>).append(txt1,txt2,txt3);        <span class=\"comment\">// 追加新元素</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>里面<code>txt1</code>，<code>txt2</code>，<code>txt3</code>的作用都是一样的，第一和第三个我知道是什么意思，但是第二个就有点疑惑了。<code>$(&quot;&quot;)</code>里面不是应该放选择器吗，放<code>&lt;p&gt;&lt;/p&gt;</code>是啥意思，搜索了一下，发现这个参数除了时选择器，还可以是dom对象和html字符串，html字符串就是在内存中生成新的dom，需要添加到dom树中才行。</p>\n<p>参考网址：<a href=\"https://ask.csdn.net/questions/234652\" target=\"_blank\" rel=\"noopener\">https://ask.csdn.net/questions/234652</a></p>\n</li>\n<li><p>还有<code>append()</code>是在被选元素的结尾插入元素，<code>after()</code>在被选元素之后插入内容。那这二者有什么区别呢？在这篇教程下有一位网友很好的说明了这个问题。</p>\n<p><img src=\"/2019/07/25/jQyery-2/append_prepend.png\" alt></p>\n</li>\n<li><p>对于jQuery获取和设置元素的几种方法，主要弄清楚下面几个概念。</p>\n<p><img src=\"/2019/07/25/jQyery-2/width.png\" alt></p>\n</li>\n<li><p><code>parentsUntil()</code>方法返回的是介于两个给定元素之间所有的祖先元素。</p>\n<p>用法为<code>$(&quot;子代&quot;).parentsUntil(&quot;祖先&quot;)</code>，注意子代和祖先的位置。</p>\n</li>\n</ol>\n","categories":[],"tags":["jQuery"]},{"title":"移动端适应开发坑","url":"http://yoursite.com/2019/07/24/移动端适应开发坑/","content":"<blockquote>\n<p>今天开始多人合作移动端网页的开发，写个笔记记录遇到的难题</p>\n</blockquote>\n<ul>\n<li><p>在开始动手之前，我先搜索了一番移动端适配的问题总结，下面是初步搜到的结果。</p>\n<ol>\n<li><p>在针对移动端开发时，先在<code>&lt;head&gt;</code>标签中多加一个<code>&lt;meta&gt;</code>标签来定义<code>viewport</code>这个属性。</p>\n<p>其中有一些在我看来较为常用的属性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width：控制viewport的宽度，这个值可以使用像素值指定也可以用“device-width”设置视口宽度为设备宽度。这个属性的话我希望我的页面始终和所在屏幕一样宽，使用设置为“device-width”。</span><br><span class=\"line\">height：控制viewport的高度。一般开发的页面都是长页面，所以很少指定高度，这个属性暂且用不上。</span><br><span class=\"line\">initial-scale：初始缩放比例，即每一次加载时页面缩放的比例。这个属性的公式为“设备宽度/网页显示宽度”，所以当值大于1时是缩小，小于1是放大。正常情况下是设置为1的。</span><br><span class=\"line\">user-scaleable：是否允许用户缩放，可以传“yes”或“no”。我作为一个初试小刀的选手，也不晓得缩放之后会有什么效果，为了保险先设置为“no”。</span><br><span class=\"line\">maximum-scale/minimum-scale：允许用户缩放到的最大/最小缩放比例。</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>还有一个是关于设备像素值的问题。之前设计的小伙伴说苹果手机的设计规范是左右边距都得留30px的距离，因为在手机上那片区域可能对手指操作没有感应。但是在设计稿中实际设置的数值则是15px，有点疑惑为什么是两倍，这次搜索也看到了原因。</p>\n<p>这与DPR值有关：</p>\n<p><img src=\"/2019/07/24/移动端适应开发坑/DPR.png\" alt></p>\n</li>\n<li><p>CSS的<code>vw</code>属性很适合用在自适应上，<code>vw</code>是可视窗口的宽度单位，和百分比有点一样，<code>1vw</code>=可视窗口的宽度的百分之一。与之对应的是<code>vh</code>，表示高度。只是一般我们倾向于使用<code>vw</code>，而不是<code>vh</code>。因为屏幕的宽度一般不会有太大改变，但高度有可能随着键盘的弹出或其他原因而改变，所以我们尽量减少使用<code>vh</code>。还可以配合<code>rem</code>和百分比等单位一起使用，更好的实现自适应。</p>\n</li>\n</ol>\n</li>\n<li><p>动手之中的问题</p>\n<ol>\n<li><p>单位</p>\n<p>之前使用<code>rem</code>觉得可以通过控制<code>html</code>标签的<code>font-size</code>控制全局的大小。于是我把<code>html</code>的<code>font-size</code>设为<code>1vw</code>，但是这样的话在其他选择器中使用<code>rem</code>代替<code>vw</code>去做单位时在手机（iPhone6）上尺寸显示正常在浏览器上却大小很奇怪。把之前用的<code>rem</code>改成<code>vw</code>就正常了，玄学~</p>\n</li>\n<li><p>设置字体在盒子中垂直居中，一行字的话可以设置<code>line-height</code>为盒子的高，就实现了。</p>\n</li>\n</ol>\n</li>\n</ul>\n<blockquote>\n<p>参考博文：<a href=\"https://blog.csdn.net/hjc256/article/details/83097907\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hjc256/article/details/83097907</a></p>\n</blockquote>\n","categories":[],"tags":["移动端"]},{"title":"jQuery_1","url":"http://yoursite.com/2019/07/23/jQuery-1/","content":"<h3 id=\"jQuery学习笔记\"><a href=\"#jQuery学习笔记\" class=\"headerlink\" title=\"jQuery学习笔记\"></a>jQuery学习笔记</h3><ol>\n<li><p>元素的选取</p>\n<p>在原生中，通常使用<code>get</code>方法获取HTML文档中的元素，通常要写很长的一段表达式，较为不方便。</p>\n<p>使用jQuery则比较便捷的获取元素，使用<code>$(&quot;&quot;)</code>获取元素，双引号内的元素获取方法和CSS选择器是一样的，比如获取<code>&lt;p&gt;</code>标签的元素，则使用<code>$(&quot;p&quot;)</code>。</p>\n</li>\n<li><p>事件</p>\n<p>jQuery里的事件<code>ready</code>和原生的<code>onload</code>很类似，但是有些小区别</p>\n<p><img src=\"/2019/07/23/jQuery-1/1.jpg\" alt></p>\n<p>其他事件的话应该都大同小异，需要用到时查文档即可。</p>\n</li>\n<li><p>效果</p>\n<p>jQuery还封装了一系列函数可以写很少的语句就改变元素的状态以及改变过程的动画。</p>\n<p>其中规定自定义动画时，要用驼峰命名法去引用CSS的属性。且无法规定颜色属性除非另外安装插件。</p>\n</li>\n<li><p>动画</p>\n<p>使用动画队列可以使多个动画逐一进行，其中引入了队列的数据结构。</p>\n</li>\n<li><p>链</p>\n<p>jQuery的链可以同时定义多个效果，较为方便的写法。</p>\n</li>\n</ol>\n<h5 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h5><p>个人感觉jQuery的很多方法就是把原生的很多函数封装之后使得可以用极短的语句完成，大大提高了打码的效率。其中的封装思想很值得学习。</p>\n","categories":[],"tags":["jQuery"]},{"title":"ES6four","url":"http://yoursite.com/2019/07/22/ES6four/","content":"<p>今天又稀里糊涂的看了几章。看的很快，囫囵吞枣。</p>\n<p>首先是<code>Promise</code>对象，<code>Generator</code>函数的语法，<code>async</code>函数。感觉这几个几乎都是和异步有关的，写法有时也能相互转化。提供了一些有利于异步操作的方法，不过没实践，暂时感觉不到多好用······</p>\n<p>然后是关于<code>class</code>的，之前看<code>ES5</code>的时候为了实现和<code>Java</code>等语言类似的类语言特性，使用了很多种方法来构造对象原型。<code>ES6</code>的<code>class</code>感觉就是把之前看的那些方法换了一种写法，实际上内部实现是一样的，以上个人感觉，也不知道准不准确，以后再回顾~</p>\n","categories":[],"tags":["ES6"]},{"title":"ES6three","url":"http://yoursite.com/2019/07/21/ES6three/","content":"<ul>\n<li><p>Symbol</p>\n<p>是一种ES6规定的新的数据类型。不能使用<code>new</code>运算符来构造，因为<code>Symbol</code>本身是值而不是对象。在创建<code>Symbol</code>值的时候，括号里的值可以用来作为该<code>Symbol</code>值的标识，但标识相同的<code>Symbol</code>值也不相等。</p>\n<p>每个<code>Symbol</code>都是独一无二的，因此适合用于实例对象添加新属性，可以避免覆盖掉原先原型里的属性等问题。</p>\n<p>将<code>Symbol</code>用作属性名时，不能使用点方法，需要使用方括号语法。因为点方法后面的属性名不能用变量表示，会被当成字符串，替换成方括号就能解决，方括号里可以使用变量。</p>\n<p><code>Sybmol</code>值作为属性名时，该属性是公开属性而不是私有属性。（这个概念还不是很清晰）</p>\n<p>使用<code>Symbol.for()</code>方法创建的值则是标识符相同的<code>Symbol</code>值相同。每使用这个方法创建值时都会先搜索是否有使用括号里的标识符且是<code>Symbol.for()</code>方法创建的<code>Symbol</code>值，若搜索到则使用那个值，搜索不到才创建新的一个。<code>Symbol.keyFor()</code>方法则返回使用<code>Symbol.for()</code>方法创建的<code>Symbol</code>值的标识符。</p>\n<p>还有很多<code>Symbol</code>的方法，有些还不能很好的理解，以后找机会再看~</p>\n</li>\n<li><p>Set</p>\n<p>感觉和集合很像，集合里的元素都是唯一的，<code>Set</code>里的数组元素也都是唯一的。可以使用数组转化为<code>Set</code>的方式去除掉数组里重复的对象。</p>\n<p>在<code>Set</code>里面，<code>NaN</code>和自身是相等的，这点和往常不同。</p>\n<p><code>WeakSet</code>里面只能存放对象，且垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用。</p>\n</li>\n<li><p>Map</p>\n<p>对象里只能用字符串做键名，Map适合对象类似的结构但是它的键名可以是各种数据类型。</p>\n<p><code>WeakMap</code>和<code>WeakSet</code>很相似，只能用对象作为键名，也是垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用。</p>\n</li>\n</ul>\n","categories":[],"tags":["ES6"]},{"title":"ES6two","url":"http://yoursite.com/2019/07/19/ES6two/","content":"<ul>\n<li><p>模板字符串</p>\n<p>可以使用反单引号`` <code>括住语句，在JavaScript语言中嵌入字符串，在字符串里面使用</code>${}<code>包住变量，是的字符串的使用更加方便。不需要用加号拼接字符串和变量。也可以嵌入其他语言，但是由于模板字符串里会自动转义字符，所以在使用</code>\\u<code>和</code>\\x<code>之类的字符可能会导致报错。为了解决这个问题，ES2018放松了对字符串的限制，对于转移出错的字符串返回</code>undefined<code>而不是报错。且在</code>raw`属性里可以得到原字符串。这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p>\n</li>\n<li><p><code>rest</code>参数</p>\n<p><code>rest</code>参数表示函数的多余参数，形式为<code>...变量名</code>。这个参数是一个数组，有了这个参数就可以不用在函数里使用<code>arguments</code>了。且因为是多余的参数，所以在参数列表里只能放在最后，另外函数的<code>length</code>属性（表示函数期望接受的参数）也不包括<code>rest</code>参数。</p>\n</li>\n<li><p>箭头函数</p>\n<p>箭头函数一定程度上简化了函数的表达式。使用<code>=&gt;</code>符号，该符号前的是传进函数的参数（当不需要参数或有多个参数时用圆括号括住），符号后的是函数的返回值（如果函数体内不止一个语句，则使用大括号并使用<code>return</code>返回值）。如果返回的是对象的话，对象外面的大括号可能会被误会为代码块，导致出错，因此若要单纯返回对象在对象外加一层圆括号。</p>\n<p><img src=\"/2019/07/19/ES6two/ES6a.png\" alt></p>\n<p>上图这个语法我有点疑惑，既然不需要返回值而且只有一句语句那为什么还要这么写呢，为什么不直接执行<code>doesNotReturn()</code>呢？等后面看看会不会接触到这种写法再说叭~</p>\n<p>箭头函数里的<code>this</code>和一般的<code>this</code>有点不同，往常函数里的<code>this</code>会随着函数执行的环境不同而不同，但是箭头函数的<code>this</code>在一开始定义的时候就固定了，在后面执行的时候<code>this</code>所指的和一开始定义时相同。</p>\n<p>原因是箭头函数没有自己的<code>this</code>，定义时的<code>this</code>就是箭头函数外层代码块的<code>this</code>。因此箭头函数不能作为构造函数，但是箭头函数会比较利于封装回调函数。</p>\n<p>箭头函数也可以用于嵌套函数，只是要注意代码可读性的问题。不要为了少些代码就疯狂使用嵌套的箭头函数，会被队友吐槽的哈哈。</p>\n<p>主要是记住箭头函数的语法和<code>this</code>的特殊性。</p>\n</li>\n</ul>\n","categories":[],"tags":["ES6"]},{"title":"ES6one","url":"http://yoursite.com/2019/07/18/ES6one/","content":"<ul>\n<li><p><code>let</code></p>\n<p>由<code>let</code>声明的变量，只在<code>let</code>所在的代码块上有效。</p>\n<p>在循环中，<code>JavaScript</code>引擎内部会记住上一轮循环的值。设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>\n<p><code>let</code>声明的变量一定要在声明后使用，否则报错。</p>\n<p><code>ES6</code>明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。（暂时性死区本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。）</p>\n<p>不允许重复声明。</p>\n<p>原本想实现块级作用域需要立即执行函数表达式，有了新功能用<code>let</code>就可以实现。</p>\n<p>应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>\n<p>如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p>\n</li>\n<li><p><code>const</code></p>\n<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>\n<p><code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>\n<p>只在声明所在的块级作用域内有效。</p>\n<p>用<code>const</code>定义的引用类型的数据，只能保证指针不变，但是指向的内存空间的数据结构就不一定了。（可以改指针指向的数据，但是不能改指向的空间）。但是可以使用<code>Object.freeze</code>方法冻结对象以及对象的属性，使得无法对对象的属性做修改。</p>\n</li>\n<li><p>顶层对象的属性</p>\n<p><code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象（<code>window</code>）的属性；<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</p>\n</li>\n<li><p><code>globalThis</code>对象</p>\n<p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是在不同实现里面是不统一的。</p>\n<p>现在规定可以用<code>globalThis</code>对象来取得顶层对象，只想全局环境下的<code>this</code>。</p>\n</li>\n<li><p><code>...</code>扩展运算符</p>\n<p>作用：将一个数组转为用逗号分隔的参数序列。</p>\n<p>参考链接：<a href=\"https://www.cnblogs.com/wangyunhui/p/7511615.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/wangyunhui/p/7511615.html</a></p>\n</li>\n<li><p>解构赋值</p>\n<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p>\n<p>只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>\n<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>\n<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>\n<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>\n<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>\n<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>\n<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>\n</li>\n</ul>\n","categories":[],"tags":["ES6"]},{"title":"jsNote6","url":"http://yoursite.com/2019/07/17/jsNote6/","content":"<h4 id=\"捋一遍思路\"><a href=\"#捋一遍思路\" class=\"headerlink\" title=\"捋一遍思路\"></a>捋一遍思路</h4><ul>\n<li><p>面向对象的程序设计</p>\n<ul>\n<li><p>理解属性</p>\n<p>数据属性：<code>configurable</code>，<code>enumerable</code>，<code>writable</code>，<code>value</code>。</p>\n<p>访问器属性：<code>configurable</code>，<code>enumerable</code>，<code>get</code>，<code>set</code>。</p>\n<p>方法：<code>Object.defineProperty()</code>，<code>Object.defineProperties()</code>，<code>Object.getOwnPropertyDescriptor()</code>。</p>\n</li>\n<li><p>创建对象</p>\n<ol>\n<li><p>工厂模式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\">\to.name = name;</span><br><span class=\"line\">\to.age = age;</span><br><span class=\"line\">\to.job = job;</span><br><span class=\"line\">\to.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>, <span class=\"string\">\"Software Engineer\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">\"Greg\"</span>, <span class=\"number\">27</span>, <span class=\"string\">\"Doctor\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>好处：可以创造多个相似对象。</p>\n<p>缺点：没有解决对象识别的问题。（即没法判断对象的类型）</p>\n</li>\n<li><p>构造函数模式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.job = job;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">\t\talert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>, <span class=\"string\">\"Software Engineer\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Greg\"</span>, <span class=\"number\">27</span>, <span class=\"string\">\"Doctor\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>tip：构造函数始终应该以大写字母开头，而非构造函数则应该以一个小写字母开头。</p>\n<p>后面<code>new</code>出来的两个实例都有一个<code>constructor</code>属性，该属性指向<code>Person</code>。</p>\n<p>优点：可以检测对象类型。（<code>instanceof</code>）</p>\n<p>缺点：每个实例都会创建一个新的相同的方法，无法实现函数复用，浪费内存。</p>\n</li>\n<li><p>原型模式</p>\n<p>我们创建的每个函数都有一个<code>prototype</code>（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享它所包含的属性和方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Person.prototype.name = <span class=\"string\">\"Nicholas\"</span>;</span><br><span class=\"line\">Person.prototype.age = <span class=\"number\">29</span>;</span><br><span class=\"line\">Person.prototype.job = <span class=\"string\">\"Software Engineer\"</span>;</span><br><span class=\"line\">Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person1.sayName();\t\t<span class=\"comment\">//\"Nicholas\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person();</span><br><span class=\"line\">person2.sayName();\t\t<span class=\"comment\">//\"Nicholas\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">alert(person1.sayName == person2.sayName);\t\t<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n<p>tip：当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。</p>\n<p>使用<code>hasOwnPertitype()</code>方法可以检测一个属性是存在于实例中，还是存在于原型中。</p>\n<p>可以使用对象字面量来重写整个原型对象，但要记得在这种方式下要指定<code>contructor</code>属性（最好用<code>Object.defineProperty()</code>方法设定）。</p>\n<p>好处：可以让所有对象实例共享它包含的属性和方法。</p>\n<p>缺点：如果对原型中的引用类型做出修改，修改可能会反映在所有实例上，或许不会是我们想要的结果。</p>\n</li>\n<li><p>组合模式</p>\n<p>实例属性（有可能根据实例不同而不同的属性）在构造函数中定义，由所有实例共享的属性和方法（固定不变的方法和属性）则是在原型中定义的。</p>\n<p>这是用来定义引用类型的一种默认模式。</p>\n</li>\n<li><p>动态原型模式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//属性</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.job = job;</span><br><span class=\"line\">    <span class=\"comment\">//方法</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span>.sayName != <span class=\"string\">\"function\"</span>)&#123;</span><br><span class=\"line\">        Person.prototype.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            alert(<span class=\"keyword\">this</span>.name);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> friend = <span class=\"keyword\">new</span> Person(<span class=\"string\">\"Nicholas\"</span>, <span class=\"number\">29</span>, <span class=\"string\">\"Software Engineer\"</span>);</span><br><span class=\"line\">friend.sayName();</span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>   tip：不能使用对象字面量重写原型。\n\n6. 寄生构造函数模式\n\n   基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。\n\n   和工厂模式很类似。\n\n7. 稳妥构造函数模式\n\n   稳妥对象：没有公共属性，而且其方法也不引用`this`的对象。</code></pre><ul>\n<li><p>继承</p>\n<ol>\n<li><p>原型链</p>\n<p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.property = <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SuperType.prototype.getSuperValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.property;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.subprototype = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//继承了SupType</span></span><br><span class=\"line\">SupType.prototype = <span class=\"keyword\">new</span> SuperType();</span><br><span class=\"line\"></span><br><span class=\"line\">SubType.prototype.getSubValue = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subproperty;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">alert(instance.getSuperValue);\t\t<span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n</ol>\n</li>\n</ul>\n<pre><code>   继承是通过创建`SuperType`的实例，并将该实例赋给`SubType.prototype`实现的。实现的本质是重写原型对象，代之以一个新类型的实例。\n\n   所有函数的默认原型都是`Object`的实例。\n\n   缺点：1.在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。 2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。\n\n2. 借用构造函数（伪造对象或经典继承）\n\n   基本思想：在子类型构造函数的内部调用超类型构造函数\n\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SuperType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.colors = [<span class=\"string\">\"red\"</span>, <span class=\"string\">\"blue\"</span>, <span class=\"string\">\"green\"</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubType</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//继承了SuperType</span></span><br><span class=\"line\">    SuperType.call(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance1 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">instance1.colors.push(<span class=\"string\">\"black\"</span>);</span><br><span class=\"line\">alert(instance1.colors);\t<span class=\"comment\">//\"red,blue,green,black\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> instance2 = <span class=\"keyword\">new</span> SubType();</span><br><span class=\"line\">alert(instance2.colors);\t<span class=\"comment\">//\"red,blue,green\"</span></span><br></pre></td></tr></table></figure>\n\n\n   优势：可以在子类型构造函数中向超类型构造函数传递参数。</code></pre><p>未完待续。。。</p>\n","categories":[],"tags":["JavaScriptLearning"]},{"title":"canvasLearning","url":"http://yoursite.com/2019/07/16/canvasLearning/","content":"<h3 id=\"使用-lt-canvas-gt\"><a href=\"#使用-lt-canvas-gt\" class=\"headerlink\" title=\"使用&lt;canvas&gt;\"></a>使用<code>&lt;canvas&gt;</code></h3><h4 id=\"绘制图形\"><a href=\"#绘制图形\" class=\"headerlink\" title=\"绘制图形\"></a>绘制图形</h4><ul>\n<li><p><code>&lt;canvas&gt;</code>元素本身用<code>width</code>和<code>height</code>来设置宽高，一般不要用CSS来设置这两个属性，因为如果用CSS则有可能在绘制过程中扭曲图像。</p>\n</li>\n<li><p>如果浏览器不支持这个标签，那么标签里的内容如图片或文字才会作为替换内容显现出来。若支持，则<code>&lt;canvas&gt;</code>和<code>&lt;/canvas&gt;</code>标签之间的内容将会被忽略。所以不能省略结束标签<code>&lt;/canvas&gt;</code>，否则<code>&lt;canvas&gt;</code>标签后面的内容都会被当作替换内容，在支持<code>&lt;canvas&gt;</code>的情况下那些内容都不会显现出来。</p>\n</li>\n<li><p><code>&lt;canvas&gt;</code>元素公开的一个或多个渲染上下文可以用来绘制和处理要展示的内容。可以使用<code>getContext()</code>方法来获取相应的渲染上下文和它的绘图功能。若要绘制2D图像，则可以传入参数<code>2d</code>，以此来获得绘制2D图像的渲染上下文。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">\"canvas\"</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> ctx = canvas.getContext(<span class=\"string\">\"2d\"</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>栅格</p>\n<p>在用<code>&lt;canvas&gt;</code>元素创造出来的画布空间里，会有一个默认的坐标网格（栅格），每一像素是一个坐标单位，起点坐标在左上角<code>(0,0)</code>。向右向下是<code>x</code>，<code>y</code>轴的正方向。</p>\n</li>\n<li><p>绘制矩形的方法</p>\n<ul>\n<li><p><code>fillRect(x,y,width,height)</code>绘制一个填充的矩形（fill）</p>\n</li>\n<li><p><code>strokeRect(x,y,width,height)</code>绘制一个矩形的边框（stroke）</p>\n</li>\n<li><p><code>clearRect(x,y,width,height)</code>清除指定矩形区域，让清除部分完全透明（clear）</p>\n<p><code>x</code>，<code>y</code>是坐标，<code>width</code>，<code>height</code> 是矩形的宽高。</p>\n</li>\n</ul>\n</li>\n<li><p>绘制路径的方法</p>\n<ul>\n<li><code>beginPath()</code>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</li>\n<li><code>closePath()</code>闭合路径之后图形绘制命令又重新指向到上下文中。但图形原本就是闭合的时候，使用这个方法不会有改变。</li>\n<li><code>stroke()</code>通过线条来绘制轮廓。</li>\n<li><code>fill()</code>通过填充路径的内容区域生成实心的图形。调用这个方法时，没有闭合的图形自动闭合。</li>\n</ul>\n</li>\n<li><p>移动笔触</p>\n<p><code>moveTo(x,y)</code>将笔触移动到指定的坐标<code>x</code>以及<code>y</code> 上。</p>\n</li>\n<li><p>绘制线条</p>\n<p>直线：<code>lineTo(x,y)</code>绘制一条从当前位置到指定<code>x</code>以及<code>y</code>位置的直线。</p>\n<p>圆弧：</p>\n<ol>\n<li><p><code>arc(x,y,radius,startAngle,endAngle,anticlockwise)</code></p>\n<p>画一个以<code>(x,y)</code>为圆心的以<code>radius</code>为半径的圆弧（圆），从<code>startAngle</code>开始到<code>endAngle</code>结束，按照<code>anticlockwise</code>给定的方向（默认为顺时针）来生成。</p>\n<p><code>x,y</code>为绘制圆弧所在圆上的圆心坐标。<code>radius</code>为半径。<code>startAngle</code>以及<code>endAngle</code>参数用弧度定义来开始及结束的弧度，这些都是以<code>x</code>轴为基准。参数<code>anticlockwise</code>为一个布尔值，为<code>true</code>时，是逆时针方向，否则顺时针方向。</p>\n</li>\n<li><p><code>arcTo(x1,y1,x2,y2,radius)</code>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。</p>\n</li>\n</ol>\n<p>二次贝塞尔曲线及三次贝塞尔曲线</p>\n<p>主要是理解贝塞尔曲线的控制点和起始点结束点</p>\n<ul>\n<li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code>，绘制二次贝塞尔曲线，<code>cp1x,cp1y</code>为一个控制点，<code>x,y</code>为结束点。</li>\n<li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code>，绘制三次贝塞尔曲线，<code>cp1x,cp1y</code>为控制点一，<code>cp2x,cp2y</code>为控制点二，<code>x,y</code>为结束点。</li>\n</ul>\n</li>\n<li><p>矩形</p>\n<p><code>rect(x, y, width, height)</code>绘制一个左上角坐标为<code>(x,y)</code>，宽高为<code>width</code>以及<code>height</code>的矩形。</p>\n<p>当该方法执行的时候，<code>moveTo()</code>方法自动设置坐标参数<code>(0,0)</code>。也就是说，当前笔触自动重置回默认坐标。</p>\n</li>\n<li><p><code>Path2D()</code>对象</p>\n<p>方便用于保存路径的对象。</p>\n</li>\n</ul>\n<h4 id=\"样式\"><a href=\"#样式\" class=\"headerlink\" title=\"样式\"></a>样式</h4><h5 id=\"上色\"><a href=\"#上色\" class=\"headerlink\" title=\"上色\"></a>上色</h5><ul>\n<li><p><code>fillStyle = color</code>设置图形的填充颜色。</p>\n</li>\n<li><p><code>strokeStyle = color</code>设置图形轮廓的颜色。</p>\n</li>\n<li><p><code>globalAlpha = transparencyValue</code>这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。</p>\n<p>tips：<code>color</code>需是有效的符合<code>CSS3颜色值标准</code>的字符串。以上三个值是设置之后绘制的图形的颜色透明度等值，就好像拿画笔画画上的一部分先取色一样，不会对之前画好已经规定好颜色的区域造成影响。</p>\n</li>\n</ul>\n<h5 id=\"线型（线的样式）\"><a href=\"#线型（线的样式）\" class=\"headerlink\" title=\"线型（线的样式）\"></a>线型（线的样式）</h5><ul>\n<li><code>lineWidth = value</code>设置线条宽度。属性值必须为正数，默认值是<code>1.0</code>。有时会出现半渲染的情况。</li>\n<li><code>lineCap = type</code>设置线条末端样式。有<code>butt(默认)</code>，<code>round</code>，<code>square(端点处加上了等宽且高度为一半线宽的方块)</code>三种取值。</li>\n<li><code>lineJoin = type</code>设定线条与线条间接合处的样式。有<code>round(边角处被磨圆了。圆的半径等于线宽)</code>，<code>bevel(交接处是平的)</code>，<code>miter(默认，线段会在连接处外侧延伸直至交于一点)</code>三种取值。</li>\n<li><code>miterLimit = value</code>限制当两条线相交时交接处最大长度，所谓交接处长度（斜接长度）是指线条交接处内角顶到外角顶点的长度。如果交点距离大于此值，连接效果会变成<code>bevel</code>。</li>\n<li><code>getLineDash()</code>返回一个包含当前虚线样式，长度为非负偶数的数组。</li>\n<li><code>setLineDash(segments)</code>设置当前虚线样式。接受一个数组，来指定线段与间隙的交替。</li>\n<li><code>lineDashOffset = value</code>设置虚线样式的起始偏移量。</li>\n</ul>\n<h5 id=\"渐变Gradients\"><a href=\"#渐变Gradients\" class=\"headerlink\" title=\"渐变Gradients\"></a>渐变<code>Gradients</code></h5><ul>\n<li><code>createLinearGradient(x1, y1, x2, y2)</code>，<code>(x1,y1)</code> 表示渐变的起点，<code>(x2,y2)</code>表示终点 。</li>\n<li><code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code>，前三个参数定义一个以<code>(x1,y1)</code>为原点，半径为<code>r1</code>的起始圆，后三个参数则定义另一个以<code>(x2,y2)</code>为原点，半径为<code>r2</code>的结束圆。</li>\n<li><code>gradient.addColorStop(position, color)</code>，<code>position</code>是一个<code>0.0</code>与<code>1.0</code>之间的数值，表示渐变中颜色所在的相对位置。</li>\n<li><code>strokeStyle</code>和<code>fillStyle</code>属性都可以接受<code>canvasGradient</code>对象。</li>\n</ul>\n<h5 id=\"图案样式\"><a href=\"#图案样式\" class=\"headerlink\" title=\"图案样式\"></a>图案样式</h5><ul>\n<li><code>createPattern(image, type)</code>，<code>image</code>可以是一个<code>Image</code>对象的引用，或者另一个<code>canvas</code>对象。<code>Type</code>必须是下面的字符串值之一：<code>repeat</code>，<code>repeat-x</code>，<code>repeat-y</code>和<code>no-repeat</code>。</li>\n</ul>\n<h5 id=\"阴影\"><a href=\"#阴影\" class=\"headerlink\" title=\"阴影\"></a>阴影</h5><ul>\n<li><code>shadowOffsetX = float</code>阴影在<code>x</code>轴上的延伸距离，正值向右，负值向左，默认值为<code>0</code>。</li>\n<li><code>shadowOffsetY = float</code>阴影在<code>y</code>轴上的延伸距离，正值向下，负值向上，默认值为<code>0</code>。</li>\n<li><code>shadowBlur = float</code>阴影的模糊程度，默认值为<code>0</code>。</li>\n<li><code>shadowColor = color</code>阴影的颜色，标准的CSS颜色值，默认是全透明的黑色。</li>\n</ul>\n<p>……….知识点太多写不完了，上面主要是在MDN上看的，网址在此：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p>\n<ul>\n<li><p>后来借助教程的各种知识点，写了一个时钟。下面贴上代码。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>clock<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">canvas</span> <span class=\"attr\">id</span>=<span class=\"string\">\"canvas\"</span> <span class=\"attr\">width</span>=<span class=\"string\">\"400\"</span> <span class=\"attr\">height</span>=<span class=\"string\">\"400\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">canvas</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t<span class=\"built_in\">window</span>.onload = draw();</span></span><br><span class=\"line\">\t\tsetInterval(draw, 1000);</span><br><span class=\"line\"><span class=\"javascript\">\t\t<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">var</span> canvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'canvas'</span>).getContext(<span class=\"string\">\"2d\"</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//先画出底盘颜色</span></span></span><br><span class=\"line\">\t\t\tcanvas.beginPath();</span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.arc(<span class=\"number\">200</span>, <span class=\"number\">200</span>, <span class=\"number\">180</span>, <span class=\"number\">0</span>, <span class=\"built_in\">Math</span>.PI*<span class=\"number\">2</span>, <span class=\"literal\">true</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.fillStyle = <span class=\"string\">\"rgb(94, 124, 152)\"</span>;</span></span><br><span class=\"line\">\t\t\tcanvas.fill();</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//画出0，3，6，9刻度线</span></span></span><br><span class=\"line\">\t\t\tcanvas.beginPath();</span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.lineCap = <span class=\"string\">\"round\"</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.strokeStyle = <span class=\"string\">\"#fff\"</span>;</span></span><br><span class=\"line\">\t\t\tcanvas.lineWidth = 6;</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//0</span></span></span><br><span class=\"line\">\t\t\tcanvas.moveTo(200, 40);</span><br><span class=\"line\">\t\t\tcanvas.lineTo(200, 60);</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//3</span></span></span><br><span class=\"line\">\t\t\tcanvas.moveTo(200, 360);</span><br><span class=\"line\">\t\t\tcanvas.lineTo(200, 340);</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//6</span></span></span><br><span class=\"line\">\t\t\tcanvas.moveTo(360, 200);</span><br><span class=\"line\">\t\t\tcanvas.lineTo(340, 200);</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//9</span></span></span><br><span class=\"line\">\t\t\tcanvas.moveTo(40, 200);</span><br><span class=\"line\">\t\t\tcanvas.lineTo(60, 200);</span><br><span class=\"line\">\t\t\tcanvas.stroke();</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//画出其他小时刻度线</span></span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">12</span>; i++)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\t<span class=\"keyword\">if</span>(i % <span class=\"number\">3</span> == <span class=\"number\">0</span>)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tcanvas.beginPath();</span><br><span class=\"line\">\t\t\t\tcanvas.lineWidth = 3;</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\tcanvas.moveTo(<span class=\"number\">200</span>+<span class=\"number\">160</span>*<span class=\"built_in\">Math</span>.sin(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">6</span> * i), <span class=\"number\">200</span><span class=\"number\">-160</span>*<span class=\"built_in\">Math</span>.cos(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">6</span> * i));</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\tcanvas.lineTo(<span class=\"number\">200</span>+<span class=\"number\">140</span>*<span class=\"built_in\">Math</span>.sin(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">6</span> * i), <span class=\"number\">200</span><span class=\"number\">-140</span>*<span class=\"built_in\">Math</span>.cos(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">6</span> * i));</span></span><br><span class=\"line\">\t\t\t\tcanvas.stroke();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//画出分钟刻度线</span></span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">60</span>; i++)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\t<span class=\"keyword\">if</span>(i % <span class=\"number\">5</span> == <span class=\"number\">0</span>)&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\t\t<span class=\"keyword\">continue</span>;</span></span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tcanvas.beginPath();</span><br><span class=\"line\">\t\t\t\tcanvas.lineWidth = 3;</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\tcanvas.moveTo(<span class=\"number\">200</span>+<span class=\"number\">160</span>*<span class=\"built_in\">Math</span>.sin(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">30</span> * i), <span class=\"number\">200</span><span class=\"number\">-160</span>*<span class=\"built_in\">Math</span>.cos(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">30</span> * i));</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t\tcanvas.lineTo(<span class=\"number\">200</span>+<span class=\"number\">150</span>*<span class=\"built_in\">Math</span>.sin(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">30</span> * i), <span class=\"number\">200</span><span class=\"number\">-150</span>*<span class=\"built_in\">Math</span>.cos(<span class=\"built_in\">Math</span>.PI/<span class=\"number\">30</span> * i));</span></span><br><span class=\"line\">\t\t\t\tcanvas.stroke();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">var</span> sec = now.getSeconds();</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">var</span> min = now.getMinutes();</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">var</span> hr = now.getHours();</span></span><br><span class=\"line\">\t\t\thr = hr&gt;=12 ? hr-12 : hr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//画出时针</span></span></span><br><span class=\"line\">\t\t\tcanvas.beginPath();</span><br><span class=\"line\">\t\t\tcanvas.moveTo(200, 200);</span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.strokeStyle = <span class=\"string\">\"white\"</span>;</span></span><br><span class=\"line\">\t\t\tcanvas.lineWidth = 4;</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">var</span> hrAng = <span class=\"built_in\">Math</span>.PI/<span class=\"number\">6</span>*hr + <span class=\"built_in\">Math</span>.PI/<span class=\"number\">360</span>*min + <span class=\"built_in\">Math</span>.PI/<span class=\"number\">21600</span>*sec;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.lineTo(<span class=\"number\">200</span> + <span class=\"number\">90</span>*<span class=\"built_in\">Math</span>.sin(hrAng), <span class=\"number\">200</span> - <span class=\"number\">90</span>*<span class=\"built_in\">Math</span>.cos(hrAng));</span></span><br><span class=\"line\">\t\t\tcanvas.stroke();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//画出分针</span></span></span><br><span class=\"line\">\t\t\tcanvas.beginPath();</span><br><span class=\"line\">\t\t\tcanvas.moveTo(200, 200);</span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.strokeStyle = <span class=\"string\">\"white\"</span>;</span></span><br><span class=\"line\">\t\t\tcanvas.lineWidth = 3;</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">var</span> minAng = <span class=\"built_in\">Math</span>.PI/<span class=\"number\">30</span>*min + <span class=\"built_in\">Math</span>.PI/<span class=\"number\">1800</span>*sec;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.lineTo(<span class=\"number\">200</span> + <span class=\"number\">110</span>*<span class=\"built_in\">Math</span>.sin(minAng), <span class=\"number\">200</span> - <span class=\"number\">110</span>*<span class=\"built_in\">Math</span>.cos(minAng));</span></span><br><span class=\"line\">\t\t\tcanvas.stroke();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"comment\">//画出秒针</span></span></span><br><span class=\"line\">\t\t\tcanvas.beginPath();</span><br><span class=\"line\">\t\t\tcanvas.moveTo(200, 200);</span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.strokeStyle = <span class=\"string\">\"white\"</span>;</span></span><br><span class=\"line\">\t\t\tcanvas.lineWidth = 2;</span><br><span class=\"line\"><span class=\"javascript\">\t\t\t<span class=\"keyword\">var</span> secAng = <span class=\"built_in\">Math</span>.PI/<span class=\"number\">30</span>*sec;</span></span><br><span class=\"line\"><span class=\"javascript\">\t\t\tcanvas.lineTo(<span class=\"number\">200</span> + <span class=\"number\">140</span>*<span class=\"built_in\">Math</span>.sin(secAng), <span class=\"number\">200</span> - <span class=\"number\">140</span>*<span class=\"built_in\">Math</span>.cos(secAng));</span></span><br><span class=\"line\">\t\t\tcanvas.stroke();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t<span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>主要原理是设置一个定时器，每一秒获取当前时间一句即时的时分秒定好时分秒针的角度然后在画布上画出来。我这里每一秒都把整个表盘重新画了一次覆盖在之前的表盘上面，也可以先把表盘画好，用定时器画针就好，但是如果是这个方法的话记得清除之前画的针。</p>\n</li>\n</ul>\n","categories":[],"tags":["JavaScriptLearning"]},{"title":"jsNote5","url":"http://yoursite.com/2019/07/15/jsNote5/","content":"<h4 id=\"函数表达式\"><a href=\"#函数表达式\" class=\"headerlink\" title=\"函数表达式\"></a>函数表达式</h4><ul>\n<li>闭包是指有权访问另一个函数作用域中的变量的函数。</li>\n<li>后台的每个执行环境都有一个表示变量的对象——变量对象。执行环境中定义的所有变量和函数都保存在这个对象里。</li>\n<li>作用域链本质上使一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</li>\n<li>闭包只能取得包含函数中任何变量的最后一个值。</li>\n<li>匿名函数的执行环境具有全局性，因此其<code>this</code>对象通常指向<code>window</code>。</li>\n<li>JavaScript中没有私有成员的概念，所有对象属性都是公有的。不管在任何函数中定义的变量，都可以认为是私有变量。有权访问私有变量和私有函数的公有方法称为特权方法。</li>\n</ul>\n","categories":[],"tags":["JavaScriptLearning"]},{"title":"随笔","url":"http://yoursite.com/2019/07/14/随笔/","content":"<p>​        今天是来工作室培训的第七天（算上中间昨天放假）。</p>\n<p>​        这个暑假可能是难得的有一整块培训的时间。其实我觉得一个月可能会有点短，但是也觉得该回家一趟。所以下个月还是会回家一段时间，希望回家了也能静得下心来学习吧。</p>\n<p>​        这两天一直在看高程，有些地方还是有点绕的，希望能赶紧看完，但是主要还是想理解的透彻一点。在未来的学习生涯我更希望把基础打好，最想培养的是持续学习的能力，感觉其中基础扎实很重要，也才能支持我将来走的更远。</p>\n<p>​        每天在这里过的都快乐又愧疚，快乐是觉得氛围真的很好，环境也很舒适，我前两天甚至过上了养生的生活，每天也能有学习的时间。愧疚的是感觉我还不够认真，每天学习的时长好像不够多，但是在规定时间外我真的很难使自己静下心来学习，希望接下来能更好的约束自己吧。</p>\n","categories":[],"tags":["life"]},{"title":"jsNote4","url":"http://yoursite.com/2019/07/12/jsNote4/","content":"<ul>\n<li><code>sort(比较函数)</code>方法的内部原理是冒泡排序。</li>\n<li><code>slice()</code>方法包含起始位置的项，不包含结束位置的项。</li>\n<li>使用迭代方法注意浏览器是否支持。</li>\n<li><code>Date</code>类型保存的日期能够精确到1970年1月1日之前或之后的100,000,000年。</li>\n<li>正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新的RegExp实例都是一个新实例。</li>\n<li>在正则表达式模式中是否使用g决定了<code>exec()</code>方法能否查找到多个匹配项，若是不使用则将始终返回第一个匹配项的信息，若是使用则每次调用都会在字符串中查找新的匹配信息。</li>\n<li>使用不带圆括号的函数名是访问函数指针，而非调用函数。</li>\n<li>不要再严格模式下使用<code>callee</code>和<code>caller</code>属性。</li>\n<li>在ECMAScript5中，<code>prototype</code>属性是不可枚举的，因此在使用<code>for-in</code>时无法发现。</li>\n<li>引用类型和基本包装类型的主要区别就是对象的生存期，使用<code>new</code>操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间。</li>\n<li>布尔表达式中的所有对象都会被转换成<code>true</code>。建议不要使用<code>Boolean</code>对象。</li>\n<li>数据属性：<code>Configurable</code>，<code>Enumerable</code>，<code>Writable</code>，<code>Value</code>。</li>\n<li>一旦把属性定义为不可配置的，就不能再把它变为可配置的了。可以多次调用<code>Object.defineProperty()</code>方法修改同一属性，但在把<code>configurable</code>特性设置为<code>false</code>之后就会有限制了。</li>\n<li>在调用<code>Object.defineProperty()</code>方法时，如果不指定，<code>configurable</code>、<code>enumerable</code>和<code>writable</code>特性的默认值都是<code>false</code>。</li>\n</ul>\n","categories":[],"tags":["JavaScriptLearning"]},{"title":"jsNote3","url":"http://yoursite.com/2019/07/11/jsNote3/","content":"<ul>\n<li><p>ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。</p>\n</li>\n<li><p><code>for-in</code>语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (property in expression) statement</span><br></pre></td></tr></table></figure>\n\n<p>一种精确的迭代语句，可以用来枚举对象的属性。</p>\n<p>如果表示要迭代的对象的变量值为<code>null</code>或<code>undefined</code>，<code>for-in</code>语句会抛出错误。ECMAScript5更正了这一行为，对这种情况不再抛出错误，而只是不执行循环体。</p>\n</li>\n<li><p><code>label</code>语句</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label: statement</span><br></pre></td></tr></table></figure>\n\n<p>使用该语句可以在代码中添加标签，以便将来使用。</p>\n<p>加标签的语句一般都要与<code>for</code>语句等循环语句配合使用。、</p>\n</li>\n<li><p><code>break</code>和<code>continue</code>语句都可以与<code>label</code>语句联合使用，比如可以使用标签一次跳出多层的嵌套循环。</p>\n</li>\n<li><p><code>with</code>语句的作用是将代码的作用域设置到一个特定的对象中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with (expression) statement</span><br></pre></td></tr></table></figure>\n\n<p>比如</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var qs = location.search.substring(1);</span><br><span class=\"line\">var hostName = location.hostName;</span><br><span class=\"line\">var url = location.href;</span><br></pre></td></tr></table></figure>\n\n<p>可以改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">with(location)&#123;</span><br><span class=\"line\">\tvar qs = search.substring(1);</span><br><span class=\"line\">\tvar hostName = hostName;</span><br><span class=\"line\">\tvar url = href;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>严格模式下不允许使用<code>with</code>语句，否则将视为语法错误。也不建议使用这个语句。</p>\n</li>\n<li><p>使用<code>switch</code>语句时记得加<code>break;</code>。可以在<code>switch</code> 语句中使用任何数据类型。该语句在比较值的时候使用的是全等操作符，因此不会发生类型转换。</p>\n</li>\n<li><p>ECMAScript中的参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）</p>\n<p><code>arguments</code>对象只能在函数中使用。</p>\n<p><code>arguments</code>的值永远与对应命名参数的值保持同步。但它们的内存空间是独立的。</p>\n</li>\n<li><p>函数不能重载。</p>\n</li>\n<li><p>基本类型—-&gt;栈，引用类型—-&gt;堆</p>\n</li>\n<li><p>函数的参数都是按值传递的，即使是引用类型也是传递了指针的值进去。相当于复制了实参的值给形参，函数内部改变的只是形参的值。但当传递引用类型的值进函数时，对形参的操作可能会影响到传进去的那个实参，是因为形参和实参指向的都是堆中的同一个地址。函数内对形参的操作实际上就是在对堆里面那块内存动手脚。</p>\n</li>\n<li><p><code>instanceof()</code>用来检测对象的类型。</p>\n<p>语法：<code>result = variable instanceof constructor</code></p>\n</li>\n<li><p>所有引用类型的值都是Object的实例。</p>\n</li>\n<li><p>每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。</p>\n</li>\n<li><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。用途是保证对执行环境有权访问的所有变量和函数的有序访问。内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。</p>\n</li>\n<li><p>使用<code>var</code>声明的变量会自动被添加到最接近的环境中。如果初始化变量是没有使用<code>var</code>声明，该变量会自动添加到全局环境。</p>\n</li>\n<li><p>如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。</p>\n</li>\n<li><p>引用计数的垃圾清除算法可能会出现循环引用，无法释放内存。</p>\n</li>\n<li><p>只要在IE中涉及COM对象，就会存在循环引用的问题。IE9将BOM和DOM对象转化成立真正的JavaScript对象，避免了两种垃圾收集算法并存导致的问题。</p>\n</li>\n<li><p>浏览器的垃圾收集器是周期性运行的，触发机制不同浏览器可能会有差异。在IE中可以用<code>window.CollectGarbage()</code>是垃圾收集立刻执行，在Opera7及更高版本中，调用<code>window.opera.collect()</code>也可以启动垃圾收集例程。但不建议程序员主动触发垃圾收集过程。</p>\n</li>\n<li><p>一旦数据不再有用，最好通过将其值设置为<code>null</code>来释放其引用，这个做法叫做解除引用。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。适用于大多数全局变量和全局对象的属性。为执行中的代码只保存必要的数据是优化内存占用的最佳方式。</p>\n</li>\n<li><p>表达式上下文指的是该上下文期待一个值（表达式）。</p>\n</li>\n<li><p>在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号内。</p>\n</li>\n<li><p><code>join()</code>方法可以指定数组元素输出为字符串时的分隔符。</p>\n</li>\n<li><p>数组的<code>pop()</code>方法返回的是取得的值，<code>push()</code>方法返回的数组长度。</p>\n</li>\n<li><p>用<code>shift()</code>和<code>push()</code>方法可以实现类似于队列先进先出的数据结构。<code>unshift()</code>和<code>pop()</code>可以实现与队列相反的操作，队头进，队尾出。</p>\n</li>\n</ul>\n","categories":[],"tags":["JavaScriptLearning"]},{"title":"jsNote2","url":"http://yoursite.com/2019/07/10/jsNote2/","content":"<ul>\n<li><p>虽然JavaScript中可以不用分号来结尾（由解析器确定语句的结尾），但是建议任何时候都不要省略分号在语句结束处。好处是增加代码可读性、可以删去不必要的空格来节约空间、增进代码的性能（节约解析器推测语句结尾的时间）</p>\n</li>\n<li><p>关键字和保留字（将来有可能被用作关键字）不能用作标识符。</p>\n<p>在实现ECMAScript3的JavaScript引擎中如果使用关键字作为标识符，会导致<code>&quot;Identifier Expected&quot;</code>错误。而使用保留字作标识符可能会也可能不会导致相同的错误，具体取决于特定的引擎。</p>\n</li>\n<li><p>变量定义后若还未赋值，则会保存一个特殊的值<code>undefined</code>。</p>\n</li>\n<li><p>用<code>var</code>定义的变量将成为定义该变量的作用域中的局部变量。即如果在函数中用<code>var</code>定义了变量，该变量在函数退出后就会被销毁。如果省略<code>var</code>操作符，则可以之间创建一个全局变量，在函数退出后该变量依旧有效。</p>\n<p>要注意的是，要先让创建全局变量所在的函数中执行过一次后该变量才会生效，否则变量为未定义。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123;</span><br><span class=\"line\">    message = &quot;hi&quot;;\t\t//全局变量</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test();</span><br><span class=\"line\">alert(message);\t\t\t//&quot;hi&quot;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123;</span><br><span class=\"line\">    message = &quot;hi&quot;;\t\t//全局变量</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">alert(message);\t\t\t//Uncaught ReferenceError: message is not defined</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在第二个例子中<code>alert</code>函数处报错了，因为在<code>alert</code>函数使用<code>message</code>前，<code>test</code>函数还未执行过，就是说<code>message = &quot;hi&quot;;</code>还未执行过，相当于<code>message</code>还未定义。</p>\n</li>\n<li><p>如果一个值是<code>null</code>，使用<code>typeof</code>操作符返回的结果也会是<code>object</code>。因为特殊值<code>null</code>被认为是一个空的对象引用（空对象指针）。</p>\n<p>Safari 5及之前版本、Chrome 7及之前版本在对正则表达式调用<code>typeof</code>操作符是会返回<code>&quot;function&quot;</code>，而其他浏览器在这种情况下会返回<code>&quot;object&quot;</code>。</p>\n</li>\n<li><p>对于尚未声明的变量只能进行一项操作，即使用<code>typeof</code>操作符检测其数据类型，返回<code>&quot;undefined&quot;</code>。</p>\n</li>\n<li><p>如果定义的变量准备在将来用于保存对象，最好将该变量初始化为<code>null</code>而不是其他值。</p>\n</li>\n<li><p>严格模式下不支持八进制字面量。</p>\n</li>\n<li><p>ECMAScript会自动将本身表示的就是一个整数的浮点数比如<code>1.0</code>、<code>1.</code>作为整数保存以节约空间。也会将小数点后面带有6个零以上的浮点数值转换为以e表示法表示的数值。</p>\n</li>\n<li><p>永远不要测试某个特定的浮点数值，因为基于IEEE754数值的浮点计算会由舍入误差。</p>\n</li>\n<li><p>如果一个数的数值超出了JavaScript的数值范围，那么这个数值会被自动转换成<code>(-)Infinity</code>表示正（负）无穷。<code>Infinity</code>不是能够参与计算的值。可以使用<code>isFinite()</code>函数来确定一个数值是不是有穷的。这个函数在参数位于最小和最大数值之间时会返回<code>true</code>。</p>\n</li>\n<li><p><code>NaN</code>表示一个本来要返回数值的操作数未返回数值的情况。</p>\n<p>任何涉及<code>NaN</code>的操作都会返回<code>NaN</code>。</p>\n<p><code>NaN</code>与任何值都不相等包括它本身，可用<code>isNaN</code>函数来判断一个值是不是<code>NaN</code>。函数在接收到一个值后，会尝试将这个值转换为数值，某些不是数值的数也可以转换为数值比如字符串<code>&quot;10&quot;</code>。任何不能转换为数值的值都会导致这个函数返回<code>true</code>。</p>\n</li>\n<li><p><code>toString()</code>方法和<code>String()</code>函数的区别</p>\n</li>\n<li><p><code>toString()</code>方法和<code>toLocaleString()</code>方法的区别</p>\n</li>\n<li><p><code>toString()</code>方法和<code>valueOf()</code>方法的区别</p>\n</li>\n<li><p>一元加操作符会像<code>Number()</code>转型函数一样对值进行数值转换。</p>\n</li>\n<li><p>按位非<code>~</code>操作的本质：操作数的负值减1。</p>\n</li>\n<li><p>左移<code>&lt;&lt;</code>和右移<code>&gt;&gt;</code>不会影响操作数的符号位。无符号右移<code>&gt;&gt;&gt;</code>会连带符号位一起移动。</p>\n</li>\n<li><p>逻辑与（或）操作不一定返回布尔值，不能在逻辑与（或）操作中使用未定义的值（但如果发生短路操作且未定义的值是第二个操作数，则不会报错）。逻辑与（或）属于短路操作，如果第一个值是<code>false</code>（<code>true</code>），则不会再对第二个操作数进行求值。</p>\n</li>\n<li><p>如果要按字母表顺序比较字符串，就必须把两个操作数转换为相同的大小写形式，再执行比较。如使用<code>toLowerCase()</code>方法。</p>\n</li>\n<li><p>在比较数字和字符串的时候，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。任何数值和<code>NaN</code>进行关系比较，结果都是<code>false</code>。</p>\n</li>\n<li><p>相等操作符在比较之前进行转换，全等操作度在比较之前不对操作数进行转换。</p>\n</li>\n</ul>\n","categories":[],"tags":["JavaScriptLearning"]},{"title":"jsNote1","url":"http://yoursite.com/2019/07/09/jsNote1/","content":"<ul>\n<li>区分好<code>&lt;script&gt;</code>标签中defer和async两个属性的区别，两个属性都是异步加载文档，只是defer是加载后不立刻执行，等HTML解析完后再执行。async是异步加载，但加载完后会停止解析HTML文档等到JavaScript文件执行完再继续解析HTML。</li>\n</ul>\n<p><img src=\"/2019/07/09/jsNote1/1.jpg\" alt=\"示意图\"></p>\n<blockquote>\n<p>图片来源于网络</p>\n</blockquote>\n<ul>\n<li><p><code>&lt;noscript&gt;</code></p>\n<p>这个标签的内容只有在脚本被禁用或不被浏览器支持的时候才会显示出来，里面可以包含一切能够出现在<code>&lt;body&gt;</code>元素中的元素。</p>\n<p>可以用这个标签在JavaScript不被浏览器支持的时候提醒用户。否则里面的内容永远不会出现在页面中。</p>\n</li>\n<li><p>严格模式</p>\n<p>要在整个脚本中启用严格模式，可以在顶部添加代码：<code>&quot;use strict&quot;;</code>。这是一个编译指示，用于告诉支持的JavaScript引擎切换到严格模式。</p>\n<p>也可以在函数内部的上方包含这条编译指示，指定函数在严格模式下执行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function doSomething()&#123;</span><br><span class=\"line\">    &quot;use strict&quot;;</span><br><span class=\"line\">    //函数体</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n","categories":[],"tags":["JavaScriptLearning"]},{"title":"学习安装配置的心得","url":"http://yoursite.com/2019/07/09/blog1/","content":"<blockquote>\n<p>很多时候我们安装某种东西，都不只是从网上下载安装包然后直接顺着一直点下一步就可以完成。往往需要从网上找教程来学习怎么把东西装好。但是大部分时候都很难找到情况和你的电脑一模一样的教程，偶尔会有些避免不了的坑，这个时候我们要怎么办呢？</p>\n</blockquote>\n<ol>\n<li><p>多找几篇教程做比对，越详细越好</p>\n<p>从我之前安装的经验来看，碰到几篇教程的有些步骤不太一样是经常的事。一开始我没经验，看到是篇教程且开头和我的情况差不多就直接照着做，等到安装到中途才发现怎么好像有些步骤被博主理所应当的忽略了。那这时候我已经过了那个步骤了，能补救还好，但有些顺序是一定的，漏了之后只能追悔莫及，那要再花多少时间就看命了。</p>\n<p>因此，吃了几次亏之后我就吸取了一点教训，每次找教程的时候都尽可能多找几篇，而且是找越详细的越好。如果能找到解释每一步的原理的话那更是谢天谢地，至少我知道哪一步是为什么，更有利于我理解不是。也能减少出错率，因为有些配置信息是要根据自身信息来代入的，若是教程里直接叫你输入某个指令但却是根据博主自身信息来写的，没有解释你稀里糊涂的跟着输入了，那简直gg啊。每一步都照着几篇博客对比着来，虽然不能保证不出错，但至少出错率要比你只单纯参照一篇来小得多。若是发现几篇博客写的不一样，再找别的教程，这种时候我建议还是少数服从多数。也可以直接搜索这个步骤的原因，说不定还能学到新的东西。</p>\n</li>\n<li><p>对照好版本号</p>\n<p>有时不同版本号之间的差异还是挺大的，所有在搜教程的时候最好加上自己下载的安装包版本号啊。</p>\n</li>\n<li><p>做好笔记</p>\n<p>如果可以的话，把你下载过程中的每一步都截图保存下来，顺便可以写一篇总结。毕竟别人写的教程和你的实操还是存在差异，尝试着把自己遇到的坑或者是每个步骤记录下来，也许以后需要重装的时候就不需要再去找教程了，甚至还可以帮助到身边的朋友哦。</p>\n</li>\n<li><p>利用错误信息</p>\n<p>学会利用电脑报给你的错误信息，复制之后直接往搜索框一丢再查一查，解决方法还蛮多的。虽然不一定有用哈哈哈，但是试试呗。</p>\n</li>\n<li><p>实在不行我们重新开始</p>\n<p>最简单粗暴的解决挫折方法大概就是重头再来了。安装的时候最好挑好你安装的路径并记住，有条理一点的安装对于你之后整理文件或者删除之类的操作会很有帮助。</p>\n<p>有时候真的明明就觉得和网上做的一模一样但是谜之就是出了错。怎么找都找不到原因，这种时候我建议你把之前下载的东西删掉，从头跟着教程来一遍，虽然这种方法比较傻瓜了点，但是相对有效。记得把之前下载的东西都删干净了再重新开始，不然保不齐你之前做的哪些操作就是罪魁祸首呢。</p>\n</li>\n<li><p>休息一下再战</p>\n<p>也许重装好几次都解决不了，那别纠结了。先睡一觉或者干点其他事情，隔段时间再来继续。说起来莫名玄学，但是我确实有好几次就是这么成功了，睡觉前怎么弄都不成功，睡一觉起来照着教程再做一遍就success了。</p>\n</li>\n<li><p>可以适当求助他人帮助</p>\n<p>其实学做这些东西的时候最爽的就是旁边有个大牛指导，不但帮你解决困难还能清清楚楚的告诉你每一步的原因。但是这个做法建议谨慎使用，自己多尝试几次之后实在不行再试着去找别人帮忙。因为偶尔别人会有自己要紧的事，也没法一直在你身边指导你，老是麻烦别人也是会有些不好意思的嘛。自己查资料去解决还有一个好处，就是提升自我学习的能力，自己实实在在踩过的坑才理解得更深刻，查资料过程中说不定还有意外的收获，比如了解到相关方面的其他知识，虽然那种一直解决不了的滋味实在难受，但是加油哈哈哈。</p>\n<p>实在无法解决就去找别人帮忙呗，也不用觉得拉不下面子，知识分享是双赢的。</p>\n</li>\n</ol>\n","categories":[],"tags":["foot"]},{"title":"Hello World","url":"http://yoursite.com/2019/07/09/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","categories":[],"tags":[]},{"title":"search","url":"http://yoursite.com/search/index.html","content":"","categories":[],"tags":[]},{"title":"category","url":"http://yoursite.com/category/index.html","content":"","categories":[],"tags":[]},{"title":"tag","url":"http://yoursite.com/tag/index.html","content":"","categories":[],"tags":[]}]