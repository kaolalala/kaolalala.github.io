<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-移动端开发记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/移动端开发记录/" class="article-date">
  <time datetime="2019-07-26T13:37:14.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/移动端开发记录/">移动端开发记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>iOS系统在点击元素触发事件时回事元素出现一瞬间的阴影，上网搜索之后发现了<code>-webkit-tap-highlight-color</code>这个属性，设置为透明度为0即可解决。</p>
<p>参考网址：<a href="https://www.cnblogs.com/libin-1/p/5903350.html" target="_blank" rel="noopener">https://www.cnblogs.com/libin-1/p/5903350.html</a></p>
</li>
<li><p>上传图片文件用到了<code>&lt;input type=&quot;file&quot;&gt;</code>这个标签，但是本身带有一些样式，想把原来的样式取消则设置<code>opacity: 0;</code>，另外想把点击输入框是外面那一圈高亮取消的话则设置<code>outline: 0;</code>。</p>
</li>
</ol>
<ul>
<li>题外话：今天的状态就很飘，学是不想学了停又不太敢停，呼！</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/26/移动端开发记录/" data-id="cjyk5l7z9000mc4utzjrgoq9t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/移动端/">移动端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jQyery-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/jQyery-2/" class="article-date">
  <time datetime="2019-07-25T13:47:05.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/jQyery-2/">jQyery_2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天继续学习jQuery</p>
<ol>
<li><p>看到添加元素的方法，里面菜鸟教程举了一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">appendText</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">var</span> txt1=<span class="string">"&lt;p&gt;文本。&lt;/p&gt;"</span>;              <span class="comment">// 使用 HTML 标签创建文本</span></span><br><span class="line"><span class="keyword">var</span> txt2=$(<span class="string">"&lt;p&gt;&lt;/p&gt;"</span>).text(<span class="string">"文本。"</span>);  <span class="comment">// 使用 jQuery 创建文本</span></span><br><span class="line"><span class="keyword">var</span> txt3=<span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span><br><span class="line">txt3.innerHTML=<span class="string">"文本。"</span>;               <span class="comment">// 使用 DOM 创建文本 text with DOM</span></span><br><span class="line">$(<span class="string">"body"</span>).append(txt1,txt2,txt3);        <span class="comment">// 追加新元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面<code>txt1</code>，<code>txt2</code>，<code>txt3</code>的作用都是一样的，第一和第三个我知道是什么意思，但是第二个就有点疑惑了。<code>$(&quot;&quot;)</code>里面不是应该放选择器吗，放<code>&lt;p&gt;&lt;/p&gt;</code>是啥意思，搜索了一下，发现这个参数除了时选择器，还可以是dom对象和html字符串，html字符串就是在内存中生成新的dom，需要添加到dom树中才行。</p>
<p>参考网址：<a href="https://ask.csdn.net/questions/234652" target="_blank" rel="noopener">https://ask.csdn.net/questions/234652</a></p>
</li>
<li><p>还有<code>append()</code>是在被选元素的结尾插入元素，<code>after()</code>在被选元素之后插入内容。那这二者有什么区别呢？在这篇教程下有一位网友很好的说明了这个问题。</p>
<p><img src="/2019/07/25/jQyery-2/append_prepend.png" alt></p>
</li>
<li><p>对于jQuery获取和设置元素的几种方法，主要弄清楚下面几个概念。</p>
<p><img src="/2019/07/25/jQyery-2/width.png" alt></p>
</li>
<li><p><code>parentsUntil()</code>方法返回的是介于两个给定元素之间所有的祖先元素。</p>
<p>用法为<code>$(&quot;子代&quot;).parentsUntil(&quot;祖先&quot;)</code>，注意子代和祖先的位置。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/25/jQyery-2/" data-id="cjyk5l7z4000hc4utrj2lmtqe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-移动端适应开发坑" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/移动端适应开发坑/" class="article-date">
  <time datetime="2019-07-24T14:19:44.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/移动端适应开发坑/">移动端适应开发坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>今天开始多人合作移动端网页的开发，写个笔记记录遇到的难题</p>
</blockquote>
<ul>
<li><p>在开始动手之前，我先搜索了一番移动端适配的问题总结，下面是初步搜到的结果。</p>
<ol>
<li><p>在针对移动端开发时，先在<code>&lt;head&gt;</code>标签中多加一个<code>&lt;meta&gt;</code>标签来定义<code>viewport</code>这个属性。</p>
<p>其中有一些在我看来较为常用的属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">width：控制viewport的宽度，这个值可以使用像素值指定也可以用“device-width”设置视口宽度为设备宽度。这个属性的话我希望我的页面始终和所在屏幕一样宽，使用设置为“device-width”。</span><br><span class="line">height：控制viewport的高度。一般开发的页面都是长页面，所以很少指定高度，这个属性暂且用不上。</span><br><span class="line">initial-scale：初始缩放比例，即每一次加载时页面缩放的比例。这个属性的公式为“设备宽度/网页显示宽度”，所以当值大于1时是缩小，小于1是放大。正常情况下是设置为1的。</span><br><span class="line">user-scaleable：是否允许用户缩放，可以传“yes”或“no”。我作为一个初试小刀的选手，也不晓得缩放之后会有什么效果，为了保险先设置为“no”。</span><br><span class="line">maximum-scale/minimum-scale：允许用户缩放到的最大/最小缩放比例。</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一个是关于设备像素值的问题。之前设计的小伙伴说苹果手机的设计规范是左右边距都得留30px的距离，因为在手机上那片区域可能对手指操作没有感应。但是在设计稿中实际设置的数值则是15px，有点疑惑为什么是两倍，这次搜索也看到了原因。</p>
<p>这与DPR值有关：</p>
<p><img src="/2019/07/24/移动端适应开发坑/DPR.png" alt></p>
</li>
<li><p>CSS的<code>vw</code>属性很适合用在自适应上，<code>vw</code>是可视窗口的宽度单位，和百分比有点一样，<code>1vw</code>=可视窗口的宽度的百分之一。与之对应的是<code>vh</code>，表示高度。只是一般我们倾向于使用<code>vw</code>，而不是<code>vh</code>。因为屏幕的宽度一般不会有太大改变，但高度有可能随着键盘的弹出或其他原因而改变，所以我们尽量减少使用<code>vh</code>。还可以配合<code>rem</code>和百分比等单位一起使用，更好的实现自适应。</p>
</li>
</ol>
</li>
<li><p>动手之中的问题</p>
<ol>
<li><p>单位</p>
<p>之前使用<code>rem</code>觉得可以通过控制<code>html</code>标签的<code>font-size</code>控制全局的大小。于是我把<code>html</code>的<code>font-size</code>设为<code>1vw</code>，但是这样的话在其他选择器中使用<code>rem</code>代替<code>vw</code>去做单位时在手机（iPhone6）上尺寸显示正常在浏览器上却大小很奇怪。把之前用的<code>rem</code>改成<code>vw</code>就正常了，玄学~</p>
</li>
<li><p>设置字体在盒子中垂直居中，一行字的话可以设置<code>line-height</code>为盒子的高，就实现了。</p>
</li>
</ol>
</li>
</ul>
<blockquote>
<p>参考博文：<a href="https://blog.csdn.net/hjc256/article/details/83097907" target="_blank" rel="noopener">https://blog.csdn.net/hjc256/article/details/83097907</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/24/移动端适应开发坑/" data-id="cjyk5l7zd000qc4utvhzpktjw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/移动端/">移动端</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jQuery-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/23/jQuery-1/" class="article-date">
  <time datetime="2019-07-23T13:40:24.000Z" itemprop="datePublished">2019-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/23/jQuery-1/">jQuery_1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="jQuery学习笔记"><a href="#jQuery学习笔记" class="headerlink" title="jQuery学习笔记"></a>jQuery学习笔记</h3><ol>
<li><p>元素的选取</p>
<p>在原生中，通常使用<code>get</code>方法获取HTML文档中的元素，通常要写很长的一段表达式，较为不方便。</p>
<p>使用jQuery则比较便捷的获取元素，使用<code>$(&quot;&quot;)</code>获取元素，双引号内的元素获取方法和CSS选择器是一样的，比如获取<code>&lt;p&gt;</code>标签的元素，则使用<code>$(&quot;p&quot;)</code>。</p>
</li>
<li><p>事件</p>
<p>jQuery里的事件<code>ready</code>和原生的<code>onload</code>很类似，但是有些小区别</p>
<p><img src="/2019/07/23/jQuery-1/1.jpg" alt></p>
<p>其他事件的话应该都大同小异，需要用到时查文档即可。</p>
</li>
<li><p>效果</p>
<p>jQuery还封装了一系列函数可以写很少的语句就改变元素的状态以及改变过程的动画。</p>
<p>其中规定自定义动画时，要用驼峰命名法去引用CSS的属性。且无法规定颜色属性除非另外安装插件。</p>
</li>
<li><p>动画</p>
<p>使用动画队列可以使多个动画逐一进行，其中引入了队列的数据结构。</p>
</li>
<li><p>链</p>
<p>jQuery的链可以同时定义多个效果，较为方便的写法。</p>
</li>
</ol>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>个人感觉jQuery的很多方法就是把原生的很多函数封装之后使得可以用极短的语句完成，大大提高了打码的效率。其中的封装思想很值得学习。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/23/jQuery-1/" data-id="cjyk5l7z0000dc4utxn6ikcts" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jQuery/">jQuery</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ES6four" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/22/ES6four/" class="article-date">
  <time datetime="2019-07-22T13:49:34.000Z" itemprop="datePublished">2019-07-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/22/ES6four/">ES6four</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天又稀里糊涂的看了几章。看的很快，囫囵吞枣。</p>
<p>首先是<code>Promise</code>对象，<code>Generator</code>函数的语法，<code>async</code>函数。感觉这几个几乎都是和异步有关的，写法有时也能相互转化。提供了一些有利于异步操作的方法，不过没实践，暂时感觉不到多好用······</p>
<p>然后是关于<code>class</code>的，之前看<code>ES5</code>的时候为了实现和<code>Java</code>等语言类似的类语言特性，使用了很多种方法来构造对象原型。<code>ES6</code>的<code>class</code>感觉就是把之前看的那些方法换了一种写法，实际上内部实现是一样的，以上个人感觉，也不知道准不准确，以后再回顾~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/22/ES6four/" data-id="cjyk5l7xn0004c4uthe4cotwx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ES6three" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/21/ES6three/" class="article-date">
  <time datetime="2019-07-21T13:28:35.000Z" itemprop="datePublished">2019-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/21/ES6three/">ES6three</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>Symbol</p>
<p>是一种ES6规定的新的数据类型。不能使用<code>new</code>运算符来构造，因为<code>Symbol</code>本身是值而不是对象。在创建<code>Symbol</code>值的时候，括号里的值可以用来作为该<code>Symbol</code>值的标识，但标识相同的<code>Symbol</code>值也不相等。</p>
<p>每个<code>Symbol</code>都是独一无二的，因此适合用于实例对象添加新属性，可以避免覆盖掉原先原型里的属性等问题。</p>
<p>将<code>Symbol</code>用作属性名时，不能使用点方法，需要使用方括号语法。因为点方法后面的属性名不能用变量表示，会被当成字符串，替换成方括号就能解决，方括号里可以使用变量。</p>
<p><code>Sybmol</code>值作为属性名时，该属性是公开属性而不是私有属性。（这个概念还不是很清晰）</p>
<p>使用<code>Symbol.for()</code>方法创建的值则是标识符相同的<code>Symbol</code>值相同。每使用这个方法创建值时都会先搜索是否有使用括号里的标识符且是<code>Symbol.for()</code>方法创建的<code>Symbol</code>值，若搜索到则使用那个值，搜索不到才创建新的一个。<code>Symbol.keyFor()</code>方法则返回使用<code>Symbol.for()</code>方法创建的<code>Symbol</code>值的标识符。</p>
<p>还有很多<code>Symbol</code>的方法，有些还不能很好的理解，以后找机会再看~</p>
</li>
<li><p>Set</p>
<p>感觉和集合很像，集合里的元素都是唯一的，<code>Set</code>里的数组元素也都是唯一的。可以使用数组转化为<code>Set</code>的方式去除掉数组里重复的对象。</p>
<p>在<code>Set</code>里面，<code>NaN</code>和自身是相等的，这点和往常不同。</p>
<p><code>WeakSet</code>里面只能存放对象，且垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用。</p>
</li>
<li><p>Map</p>
<p>对象里只能用字符串做键名，Map适合对象类似的结构但是它的键名可以是各种数据类型。</p>
<p><code>WeakMap</code>和<code>WeakSet</code>很相似，只能用对象作为键名，也是垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/21/ES6three/" data-id="cjyk5l7xb0000c4ut5hlzm88n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ES6two" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/19/ES6two/" class="article-date">
  <time datetime="2019-07-19T14:38:14.000Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/19/ES6two/">ES6two</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>模板字符串</p>
<p>可以使用反单引号`` <code>括住语句，在JavaScript语言中嵌入字符串，在字符串里面使用</code>${}<code>包住变量，是的字符串的使用更加方便。不需要用加号拼接字符串和变量。也可以嵌入其他语言，但是由于模板字符串里会自动转义字符，所以在使用</code>\u<code>和</code>\x<code>之类的字符可能会导致报错。为了解决这个问题，ES2018放松了对字符串的限制，对于转移出错的字符串返回</code>undefined<code>而不是报错。且在</code>raw`属性里可以得到原字符串。这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p>
</li>
<li><p><code>rest</code>参数</p>
<p><code>rest</code>参数表示函数的多余参数，形式为<code>...变量名</code>。这个参数是一个数组，有了这个参数就可以不用在函数里使用<code>arguments</code>了。且因为是多余的参数，所以在参数列表里只能放在最后，另外函数的<code>length</code>属性（表示函数期望接受的参数）也不包括<code>rest</code>参数。</p>
</li>
<li><p>箭头函数</p>
<p>箭头函数一定程度上简化了函数的表达式。使用<code>=&gt;</code>符号，该符号前的是传进函数的参数（当不需要参数或有多个参数时用圆括号括住），符号后的是函数的返回值（如果函数体内不止一个语句，则使用大括号并使用<code>return</code>返回值）。如果返回的是对象的话，对象外面的大括号可能会被误会为代码块，导致出错，因此若要单纯返回对象在对象外加一层圆括号。</p>
<p><img src="/2019/07/19/ES6two/ES6a.png" alt></p>
<p>上图这个语法我有点疑惑，既然不需要返回值而且只有一句语句那为什么还要这么写呢，为什么不直接执行<code>doesNotReturn()</code>呢？等后面看看会不会接触到这种写法再说叭~</p>
<p>箭头函数里的<code>this</code>和一般的<code>this</code>有点不同，往常函数里的<code>this</code>会随着函数执行的环境不同而不同，但是箭头函数的<code>this</code>在一开始定义的时候就固定了，在后面执行的时候<code>this</code>所指的和一开始定义时相同。</p>
<p>原因是箭头函数没有自己的<code>this</code>，定义时的<code>this</code>就是箭头函数外层代码块的<code>this</code>。因此箭头函数不能作为构造函数，但是箭头函数会比较利于封装回调函数。</p>
<p>箭头函数也可以用于嵌套函数，只是要注意代码可读性的问题。不要为了少些代码就疯狂使用嵌套的箭头函数，会被队友吐槽的哈哈。</p>
<p>主要是记住箭头函数的语法和<code>this</code>的特殊性。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/19/ES6two/" data-id="cjyk5l7xm0003c4utbub0g6ty" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ES6one" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/ES6one/" class="article-date">
  <time datetime="2019-07-18T13:56:06.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/ES6one/">ES6one</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p><code>let</code></p>
<p>由<code>let</code>声明的变量，只在<code>let</code>所在的代码块上有效。</p>
<p>在循环中，<code>JavaScript</code>引擎内部会记住上一轮循环的值。设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<p><code>let</code>声明的变量一定要在声明后使用，否则报错。</p>
<p><code>ES6</code>明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。（暂时性死区本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。）</p>
<p>不允许重复声明。</p>
<p>原本想实现块级作用域需要立即执行函数表达式，有了新功能用<code>let</code>就可以实现。</p>
<p>应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<p>如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p>
</li>
<li><p><code>const</code></p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p><code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p>只在声明所在的块级作用域内有效。</p>
<p>用<code>const</code>定义的引用类型的数据，只能保证指针不变，但是指向的内存空间的数据结构就不一定了。（可以改指针指向的数据，但是不能改指向的空间）。但是可以使用<code>Object.freeze</code>方法冻结对象以及对象的属性，使得无法对对象的属性做修改。</p>
</li>
<li><p>顶层对象的属性</p>
<p><code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象（<code>window</code>）的属性；<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</p>
</li>
<li><p><code>globalThis</code>对象</p>
<p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是在不同实现里面是不统一的。</p>
<p>现在规定可以用<code>globalThis</code>对象来取得顶层对象，只想全局环境下的<code>this</code>。</p>
</li>
<li><p><code>...</code>扩展运算符</p>
<p>作用：将一个数组转为用逗号分隔的参数序列。</p>
<p>参考链接：<a href="https://www.cnblogs.com/wangyunhui/p/7511615.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangyunhui/p/7511615.html</a></p>
</li>
<li><p>解构赋值</p>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p>
<p>只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/ES6one/" data-id="cjyk5l7yv000ac4ut8bx8b103" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jsNote6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/jsNote6/" class="article-date">
  <time datetime="2019-07-17T14:02:10.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/jsNote6/">jsNote6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="捋一遍思路"><a href="#捋一遍思路" class="headerlink" title="捋一遍思路"></a>捋一遍思路</h4><ul>
<li><p>面向对象的程序设计</p>
<ul>
<li><p>理解属性</p>
<p>数据属性：<code>configurable</code>，<code>enumerable</code>，<code>writable</code>，<code>value</code>。</p>
<p>访问器属性：<code>configurable</code>，<code>enumerable</code>，<code>get</code>，<code>set</code>。</p>
<p>方法：<code>Object.defineProperty()</code>，<code>Object.defineProperties()</code>，<code>Object.getOwnPropertyDescriptor()</code>。</p>
</li>
<li><p>创建对象</p>
<ol>
<li><p>工厂模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>好处：可以创造多个相似对象。</p>
<p>缺点：没有解决对象识别的问题。（即没法判断对象的类型）</p>
</li>
<li><p>构造函数模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>tip：构造函数始终应该以大写字母开头，而非构造函数则应该以一个小写字母开头。</p>
<p>后面<code>new</code>出来的两个实例都有一个<code>constructor</code>属性，该属性指向<code>Person</code>。</p>
<p>优点：可以检测对象类型。（<code>instanceof</code>）</p>
<p>缺点：每个实例都会创建一个新的相同的方法，无法实现函数复用，浪费内存。</p>
</li>
<li><p>原型模式</p>
<p>我们创建的每个函数都有一个<code>prototype</code>（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享它所包含的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();		<span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();		<span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName);		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>tip：当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。</p>
<p>使用<code>hasOwnPertitype()</code>方法可以检测一个属性是存在于实例中，还是存在于原型中。</p>
<p>可以使用对象字面量来重写整个原型对象，但要记得在这种方式下要指定<code>contructor</code>属性（最好用<code>Object.defineProperty()</code>方法设定）。</p>
<p>好处：可以让所有对象实例共享它包含的属性和方法。</p>
<p>缺点：如果对原型中的引用类型做出修改，修改可能会反映在所有实例上，或许不会是我们想要的结果。</p>
</li>
<li><p>组合模式</p>
<p>实例属性（有可能根据实例不同而不同的属性）在构造函数中定义，由所有实例共享的属性和方法（固定不变的方法和属性）则是在原型中定义的。</p>
<p>这是用来定义引用类型的一种默认模式。</p>
</li>
<li><p>动态原型模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>   tip：不能使用对象字面量重写原型。

6. 寄生构造函数模式

   基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。

   和工厂模式很类似。

7. 稳妥构造函数模式

   稳妥对象：没有公共属性，而且其方法也不引用`this`的对象。</code></pre><ul>
<li><p>继承</p>
<ol>
<li><p>原型链</p>
<p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subprototype = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SupType</span></span><br><span class="line">SupType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue);		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<pre><code>   继承是通过创建`SuperType`的实例，并将该实例赋给`SubType.prototype`实现的。实现的本质是重写原型对象，代之以一个新类型的实例。

   所有函数的默认原型都是`Object`的实例。

   缺点：1.在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。 2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。

2. 借用构造函数（伪造对象或经典继承）

   基本思想：在子类型构造函数的内部调用超类型构造函数

   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);	<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors);	<span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>


   优势：可以在子类型构造函数中向超类型构造函数传递参数。</code></pre><p>未完待续。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/17/jsNote6/" data-id="cjyk5l7zj000zc4ut2wrcbzrk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-canvasLearning" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/canvasLearning/" class="article-date">
  <time datetime="2019-07-16T13:25:27.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/canvasLearning/">canvasLearning</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="使用-lt-canvas-gt"><a href="#使用-lt-canvas-gt" class="headerlink" title="使用&lt;canvas&gt;"></a>使用<code>&lt;canvas&gt;</code></h3><h4 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h4><ul>
<li><p><code>&lt;canvas&gt;</code>元素本身用<code>width</code>和<code>height</code>来设置宽高，一般不要用CSS来设置这两个属性，因为如果用CSS则有可能在绘制过程中扭曲图像。</p>
</li>
<li><p>如果浏览器不支持这个标签，那么标签里的内容如图片或文字才会作为替换内容显现出来。若支持，则<code>&lt;canvas&gt;</code>和<code>&lt;/canvas&gt;</code>标签之间的内容将会被忽略。所以不能省略结束标签<code>&lt;/canvas&gt;</code>，否则<code>&lt;canvas&gt;</code>标签后面的内容都会被当作替换内容，在支持<code>&lt;canvas&gt;</code>的情况下那些内容都不会显现出来。</p>
</li>
<li><p><code>&lt;canvas&gt;</code>元素公开的一个或多个渲染上下文可以用来绘制和处理要展示的内容。可以使用<code>getContext()</code>方法来获取相应的渲染上下文和它的绘图功能。若要绘制2D图像，则可以传入参数<code>2d</code>，以此来获得绘制2D图像的渲染上下文。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"canvas"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>栅格</p>
<p>在用<code>&lt;canvas&gt;</code>元素创造出来的画布空间里，会有一个默认的坐标网格（栅格），每一像素是一个坐标单位，起点坐标在左上角<code>(0,0)</code>。向右向下是<code>x</code>，<code>y</code>轴的正方向。</p>
</li>
<li><p>绘制矩形的方法</p>
<ul>
<li><p><code>fillRect(x,y,width,height)</code>绘制一个填充的矩形（fill）</p>
</li>
<li><p><code>strokeRect(x,y,width,height)</code>绘制一个矩形的边框（stroke）</p>
</li>
<li><p><code>clearRect(x,y,width,height)</code>清除指定矩形区域，让清除部分完全透明（clear）</p>
<p><code>x</code>，<code>y</code>是坐标，<code>width</code>，<code>height</code> 是矩形的宽高。</p>
</li>
</ul>
</li>
<li><p>绘制路径的方法</p>
<ul>
<li><code>beginPath()</code>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</li>
<li><code>closePath()</code>闭合路径之后图形绘制命令又重新指向到上下文中。但图形原本就是闭合的时候，使用这个方法不会有改变。</li>
<li><code>stroke()</code>通过线条来绘制轮廓。</li>
<li><code>fill()</code>通过填充路径的内容区域生成实心的图形。调用这个方法时，没有闭合的图形自动闭合。</li>
</ul>
</li>
<li><p>移动笔触</p>
<p><code>moveTo(x,y)</code>将笔触移动到指定的坐标<code>x</code>以及<code>y</code> 上。</p>
</li>
<li><p>绘制线条</p>
<p>直线：<code>lineTo(x,y)</code>绘制一条从当前位置到指定<code>x</code>以及<code>y</code>位置的直线。</p>
<p>圆弧：</p>
<ol>
<li><p><code>arc(x,y,radius,startAngle,endAngle,anticlockwise)</code></p>
<p>画一个以<code>(x,y)</code>为圆心的以<code>radius</code>为半径的圆弧（圆），从<code>startAngle</code>开始到<code>endAngle</code>结束，按照<code>anticlockwise</code>给定的方向（默认为顺时针）来生成。</p>
<p><code>x,y</code>为绘制圆弧所在圆上的圆心坐标。<code>radius</code>为半径。<code>startAngle</code>以及<code>endAngle</code>参数用弧度定义来开始及结束的弧度，这些都是以<code>x</code>轴为基准。参数<code>anticlockwise</code>为一个布尔值，为<code>true</code>时，是逆时针方向，否则顺时针方向。</p>
</li>
<li><p><code>arcTo(x1,y1,x2,y2,radius)</code>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。</p>
</li>
</ol>
<p>二次贝塞尔曲线及三次贝塞尔曲线</p>
<p>主要是理解贝塞尔曲线的控制点和起始点结束点</p>
<ul>
<li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code>，绘制二次贝塞尔曲线，<code>cp1x,cp1y</code>为一个控制点，<code>x,y</code>为结束点。</li>
<li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code>，绘制三次贝塞尔曲线，<code>cp1x,cp1y</code>为控制点一，<code>cp2x,cp2y</code>为控制点二，<code>x,y</code>为结束点。</li>
</ul>
</li>
<li><p>矩形</p>
<p><code>rect(x, y, width, height)</code>绘制一个左上角坐标为<code>(x,y)</code>，宽高为<code>width</code>以及<code>height</code>的矩形。</p>
<p>当该方法执行的时候，<code>moveTo()</code>方法自动设置坐标参数<code>(0,0)</code>。也就是说，当前笔触自动重置回默认坐标。</p>
</li>
<li><p><code>Path2D()</code>对象</p>
<p>方便用于保存路径的对象。</p>
</li>
</ul>
<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><h5 id="上色"><a href="#上色" class="headerlink" title="上色"></a>上色</h5><ul>
<li><p><code>fillStyle = color</code>设置图形的填充颜色。</p>
</li>
<li><p><code>strokeStyle = color</code>设置图形轮廓的颜色。</p>
</li>
<li><p><code>globalAlpha = transparencyValue</code>这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。</p>
<p>tips：<code>color</code>需是有效的符合<code>CSS3颜色值标准</code>的字符串。以上三个值是设置之后绘制的图形的颜色透明度等值，就好像拿画笔画画上的一部分先取色一样，不会对之前画好已经规定好颜色的区域造成影响。</p>
</li>
</ul>
<h5 id="线型（线的样式）"><a href="#线型（线的样式）" class="headerlink" title="线型（线的样式）"></a>线型（线的样式）</h5><ul>
<li><code>lineWidth = value</code>设置线条宽度。属性值必须为正数，默认值是<code>1.0</code>。有时会出现半渲染的情况。</li>
<li><code>lineCap = type</code>设置线条末端样式。有<code>butt(默认)</code>，<code>round</code>，<code>square(端点处加上了等宽且高度为一半线宽的方块)</code>三种取值。</li>
<li><code>lineJoin = type</code>设定线条与线条间接合处的样式。有<code>round(边角处被磨圆了。圆的半径等于线宽)</code>，<code>bevel(交接处是平的)</code>，<code>miter(默认，线段会在连接处外侧延伸直至交于一点)</code>三种取值。</li>
<li><code>miterLimit = value</code>限制当两条线相交时交接处最大长度，所谓交接处长度（斜接长度）是指线条交接处内角顶到外角顶点的长度。如果交点距离大于此值，连接效果会变成<code>bevel</code>。</li>
<li><code>getLineDash()</code>返回一个包含当前虚线样式，长度为非负偶数的数组。</li>
<li><code>setLineDash(segments)</code>设置当前虚线样式。接受一个数组，来指定线段与间隙的交替。</li>
<li><code>lineDashOffset = value</code>设置虚线样式的起始偏移量。</li>
</ul>
<h5 id="渐变Gradients"><a href="#渐变Gradients" class="headerlink" title="渐变Gradients"></a>渐变<code>Gradients</code></h5><ul>
<li><code>createLinearGradient(x1, y1, x2, y2)</code>，<code>(x1,y1)</code> 表示渐变的起点，<code>(x2,y2)</code>表示终点 。</li>
<li><code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code>，前三个参数定义一个以<code>(x1,y1)</code>为原点，半径为<code>r1</code>的起始圆，后三个参数则定义另一个以<code>(x2,y2)</code>为原点，半径为<code>r2</code>的结束圆。</li>
<li><code>gradient.addColorStop(position, color)</code>，<code>position</code>是一个<code>0.0</code>与<code>1.0</code>之间的数值，表示渐变中颜色所在的相对位置。</li>
<li><code>strokeStyle</code>和<code>fillStyle</code>属性都可以接受<code>canvasGradient</code>对象。</li>
</ul>
<h5 id="图案样式"><a href="#图案样式" class="headerlink" title="图案样式"></a>图案样式</h5><ul>
<li><code>createPattern(image, type)</code>，<code>image</code>可以是一个<code>Image</code>对象的引用，或者另一个<code>canvas</code>对象。<code>Type</code>必须是下面的字符串值之一：<code>repeat</code>，<code>repeat-x</code>，<code>repeat-y</code>和<code>no-repeat</code>。</li>
</ul>
<h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><ul>
<li><code>shadowOffsetX = float</code>阴影在<code>x</code>轴上的延伸距离，正值向右，负值向左，默认值为<code>0</code>。</li>
<li><code>shadowOffsetY = float</code>阴影在<code>y</code>轴上的延伸距离，正值向下，负值向上，默认值为<code>0</code>。</li>
<li><code>shadowBlur = float</code>阴影的模糊程度，默认值为<code>0</code>。</li>
<li><code>shadowColor = color</code>阴影的颜色，标准的CSS颜色值，默认是全透明的黑色。</li>
</ul>
<p>……….知识点太多写不完了，上面主要是在MDN上看的，网址在此：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p>
<ul>
<li><p>后来借助教程的各种知识点，写了一个时钟。下面贴上代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>clock<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"400"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">window</span>.onload = draw();</span></span><br><span class="line">		setInterval(draw, 1000);</span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>).getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="javascript">			<span class="comment">//先画出底盘颜色</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line"><span class="javascript">			canvas.arc(<span class="number">200</span>, <span class="number">200</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">			canvas.fillStyle = <span class="string">"rgb(94, 124, 152)"</span>;</span></span><br><span class="line">			canvas.fill();</span><br><span class="line"><span class="javascript">			<span class="comment">//画出0，3，6，9刻度线</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line"><span class="javascript">			canvas.lineCap = <span class="string">"round"</span>;</span></span><br><span class="line"><span class="javascript">			canvas.strokeStyle = <span class="string">"#fff"</span>;</span></span><br><span class="line">			canvas.lineWidth = 6;</span><br><span class="line"><span class="javascript">			<span class="comment">//0</span></span></span><br><span class="line">			canvas.moveTo(200, 40);</span><br><span class="line">			canvas.lineTo(200, 60);</span><br><span class="line"><span class="javascript">			<span class="comment">//3</span></span></span><br><span class="line">			canvas.moveTo(200, 360);</span><br><span class="line">			canvas.lineTo(200, 340);</span><br><span class="line"><span class="javascript">			<span class="comment">//6</span></span></span><br><span class="line">			canvas.moveTo(360, 200);</span><br><span class="line">			canvas.lineTo(340, 200);</span><br><span class="line"><span class="javascript">			<span class="comment">//9</span></span></span><br><span class="line">			canvas.moveTo(40, 200);</span><br><span class="line">			canvas.lineTo(60, 200);</span><br><span class="line">			canvas.stroke();</span><br><span class="line"><span class="javascript">			<span class="comment">//画出其他小时刻度线</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">12</span>; i++)&#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">continue</span>;</span></span><br><span class="line">				&#125;</span><br><span class="line">				canvas.beginPath();</span><br><span class="line">				canvas.lineWidth = 3;</span><br><span class="line"><span class="javascript">				canvas.moveTo(<span class="number">200</span>+<span class="number">160</span>*<span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.PI/<span class="number">6</span> * i), <span class="number">200</span><span class="number">-160</span>*<span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.PI/<span class="number">6</span> * i));</span></span><br><span class="line"><span class="javascript">				canvas.lineTo(<span class="number">200</span>+<span class="number">140</span>*<span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.PI/<span class="number">6</span> * i), <span class="number">200</span><span class="number">-140</span>*<span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.PI/<span class="number">6</span> * i));</span></span><br><span class="line">				canvas.stroke();</span><br><span class="line">			&#125;</span><br><span class="line"><span class="javascript">			<span class="comment">//画出分钟刻度线</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">60</span>; i++)&#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">continue</span>;</span></span><br><span class="line">				&#125;</span><br><span class="line">				canvas.beginPath();</span><br><span class="line">				canvas.lineWidth = 3;</span><br><span class="line"><span class="javascript">				canvas.moveTo(<span class="number">200</span>+<span class="number">160</span>*<span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.PI/<span class="number">30</span> * i), <span class="number">200</span><span class="number">-160</span>*<span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.PI/<span class="number">30</span> * i));</span></span><br><span class="line"><span class="javascript">				canvas.lineTo(<span class="number">200</span>+<span class="number">150</span>*<span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.PI/<span class="number">30</span> * i), <span class="number">200</span><span class="number">-150</span>*<span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.PI/<span class="number">30</span> * i));</span></span><br><span class="line">				canvas.stroke();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> sec = now.getSeconds();</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> min = now.getMinutes();</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> hr = now.getHours();</span></span><br><span class="line">			hr = hr&gt;=12 ? hr-12 : hr;</span><br><span class="line"></span><br><span class="line"><span class="javascript">			<span class="comment">//画出时针</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line">			canvas.moveTo(200, 200);</span><br><span class="line"><span class="javascript">			canvas.strokeStyle = <span class="string">"white"</span>;</span></span><br><span class="line">			canvas.lineWidth = 4;</span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> hrAng = <span class="built_in">Math</span>.PI/<span class="number">6</span>*hr + <span class="built_in">Math</span>.PI/<span class="number">360</span>*min + <span class="built_in">Math</span>.PI/<span class="number">21600</span>*sec;</span></span><br><span class="line"><span class="javascript">			canvas.lineTo(<span class="number">200</span> + <span class="number">90</span>*<span class="built_in">Math</span>.sin(hrAng), <span class="number">200</span> - <span class="number">90</span>*<span class="built_in">Math</span>.cos(hrAng));</span></span><br><span class="line">			canvas.stroke();</span><br><span class="line"></span><br><span class="line"><span class="javascript">			<span class="comment">//画出分针</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line">			canvas.moveTo(200, 200);</span><br><span class="line"><span class="javascript">			canvas.strokeStyle = <span class="string">"white"</span>;</span></span><br><span class="line">			canvas.lineWidth = 3;</span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> minAng = <span class="built_in">Math</span>.PI/<span class="number">30</span>*min + <span class="built_in">Math</span>.PI/<span class="number">1800</span>*sec;</span></span><br><span class="line"><span class="javascript">			canvas.lineTo(<span class="number">200</span> + <span class="number">110</span>*<span class="built_in">Math</span>.sin(minAng), <span class="number">200</span> - <span class="number">110</span>*<span class="built_in">Math</span>.cos(minAng));</span></span><br><span class="line">			canvas.stroke();</span><br><span class="line"></span><br><span class="line"><span class="javascript">			<span class="comment">//画出秒针</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line">			canvas.moveTo(200, 200);</span><br><span class="line"><span class="javascript">			canvas.strokeStyle = <span class="string">"white"</span>;</span></span><br><span class="line">			canvas.lineWidth = 2;</span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> secAng = <span class="built_in">Math</span>.PI/<span class="number">30</span>*sec;</span></span><br><span class="line"><span class="javascript">			canvas.lineTo(<span class="number">200</span> + <span class="number">140</span>*<span class="built_in">Math</span>.sin(secAng), <span class="number">200</span> - <span class="number">140</span>*<span class="built_in">Math</span>.cos(secAng));</span></span><br><span class="line">			canvas.stroke();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>主要原理是设置一个定时器，每一秒获取当前时间一句即时的时分秒定好时分秒针的角度然后在画布上画出来。我这里每一秒都把整个表盘重新画了一次覆盖在之前的表盘上面，也可以先把表盘画好，用定时器画针就好，但是如果是这个方法的话记得清除之前画的针。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/canvasLearning/" data-id="cjyk5l7zi000xc4utymy6zqtf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/foot/">foot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">life</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/移动端/">移动端</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ES6/" style="font-size: 16.67px;">ES6</a> <a href="/tags/JavaScriptLearning/" style="font-size: 20px;">JavaScriptLearning</a> <a href="/tags/foot/" style="font-size: 10px;">foot</a> <a href="/tags/jQuery/" style="font-size: 13.33px;">jQuery</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/移动端/" style="font-size: 13.33px;">移动端</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/26/移动端开发记录/">移动端开发记录</a>
          </li>
        
          <li>
            <a href="/2019/07/25/jQyery-2/">jQyery_2</a>
          </li>
        
          <li>
            <a href="/2019/07/24/移动端适应开发坑/">移动端适应开发坑</a>
          </li>
        
          <li>
            <a href="/2019/07/23/jQuery-1/">jQuery_1</a>
          </li>
        
          <li>
            <a href="/2019/07/22/ES6four/">ES6four</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>