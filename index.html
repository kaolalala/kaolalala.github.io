<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ES6three" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/21/ES6three/" class="article-date">
  <time datetime="2019-07-21T13:28:35.000Z" itemprop="datePublished">2019-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/21/ES6three/">ES6three</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>Symbol</p>
<p>是一种ES6规定的新的数据类型。不能使用<code>new</code>运算符来构造，因为<code>Symbol</code>本身是值而不是对象。在创建<code>Symbol</code>值的时候，括号里的值可以用来作为该<code>Symbol</code>值的标识，但标识相同的<code>Symbol</code>值也不相等。</p>
<p>每个<code>Symbol</code>都是独一无二的，因此适合用于实例对象添加新属性，可以避免覆盖掉原先原型里的属性等问题。</p>
<p>将<code>Symbol</code>用作属性名时，不能使用点方法，需要使用方括号语法。因为点方法后面的属性名不能用变量表示，会被当成字符串，替换成方括号就能解决，方括号里可以使用变量。</p>
<p><code>Sybmol</code>值作为属性名时，该属性是公开属性而不是私有属性。（这个概念还不是很清晰）</p>
<p>使用<code>Symbol.for()</code>方法创建的值则是标识符相同的<code>Symbol</code>值相同。每使用这个方法创建值时都会先搜索是否有使用括号里的标识符且是<code>Symbol.for()</code>方法创建的<code>Symbol</code>值，若搜索到则使用那个值，搜索不到才创建新的一个。<code>Symbol.keyFor()</code>方法则返回使用<code>Symbol.for()</code>方法创建的<code>Symbol</code>值的标识符。</p>
<p>还有很多<code>Symbol</code>的方法，有些还不能很好的理解，以后找机会再看~</p>
</li>
<li><p>Set</p>
<p>感觉和集合很像，集合里的元素都是唯一的，<code>Set</code>里的数组元素也都是唯一的。可以使用数组转化为<code>Set</code>的方式去除掉数组里重复的对象。</p>
<p>在<code>Set</code>里面，<code>NaN</code>和自身是相等的，这点和往常不同。</p>
<p><code>WeakSet</code>里面只能存放对象，且垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用。</p>
</li>
<li><p>Map</p>
<p>对象里只能用字符串做键名，Map适合对象类似的结构但是它的键名可以是各种数据类型。</p>
<p><code>WeakMap</code>和<code>WeakSet</code>很相似，只能用对象作为键名，也是垃圾回收机制不考虑<code>WeakSet</code>对该对象的引用。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/21/ES6three/" data-id="cjyczzu400000gwutf0kg7wwb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ES6two" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/19/ES6two/" class="article-date">
  <time datetime="2019-07-19T14:38:14.000Z" itemprop="datePublished">2019-07-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/19/ES6two/">ES6two</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>模板字符串</p>
<p>可以使用反单引号`` <code>括住语句，在JavaScript语言中嵌入字符串，在字符串里面使用</code>${}<code>包住变量，是的字符串的使用更加方便。不需要用加号拼接字符串和变量。也可以嵌入其他语言，但是由于模板字符串里会自动转义字符，所以在使用</code>\u<code>和</code>\x<code>之类的字符可能会导致报错。为了解决这个问题，ES2018放松了对字符串的限制，对于转移出错的字符串返回</code>undefined<code>而不是报错。且在</code>raw`属性里可以得到原字符串。这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p>
</li>
<li><p><code>rest</code>参数</p>
<p><code>rest</code>参数表示函数的多余参数，形式为<code>...变量名</code>。这个参数是一个数组，有了这个参数就可以不用在函数里使用<code>arguments</code>了。且因为是多余的参数，所以在参数列表里只能放在最后，另外函数的<code>length</code>属性（表示函数期望接受的参数）也不包括<code>rest</code>参数。</p>
</li>
<li><p>箭头函数</p>
<p>箭头函数一定程度上简化了函数的表达式。使用<code>=&gt;</code>符号，该符号前的是传进函数的参数（当不需要参数或有多个参数时用圆括号括住），符号后的是函数的返回值（如果函数体内不止一个语句，则使用大括号并使用<code>return</code>返回值）。如果返回的是对象的话，对象外面的大括号可能会被误会为代码块，导致出错，因此若要单纯返回对象在对象外加一层圆括号。</p>
<p><img src="/2019/07/19/ES6two/ES6a.png" alt></p>
<p>上图这个语法我有点疑惑，既然不需要返回值而且只有一句语句那为什么还要这么写呢，为什么不直接执行<code>doesNotReturn()</code>呢？等后面看看会不会接触到这种写法再说叭~</p>
<p>箭头函数里的<code>this</code>和一般的<code>this</code>有点不同，往常函数里的<code>this</code>会随着函数执行的环境不同而不同，但是箭头函数的<code>this</code>在一开始定义的时候就固定了，在后面执行的时候<code>this</code>所指的和一开始定义时相同。</p>
<p>原因是箭头函数没有自己的<code>this</code>，定义时的<code>this</code>就是箭头函数外层代码块的<code>this</code>。因此箭头函数不能作为构造函数，但是箭头函数会比较利于封装回调函数。</p>
<p>箭头函数也可以用于嵌套函数，只是要注意代码可读性的问题。不要为了少些代码就疯狂使用嵌套的箭头函数，会被队友吐槽的哈哈。</p>
<p>主要是记住箭头函数的语法和<code>this</code>的特殊性。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/19/ES6two/" data-id="cjyczzu4x000dgwutr2fbpuqv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ES6one" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/ES6one/" class="article-date">
  <time datetime="2019-07-18T13:56:06.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/ES6one/">ES6one</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p><code>let</code></p>
<p>由<code>let</code>声明的变量，只在<code>let</code>所在的代码块上有效。</p>
<p>在循环中，<code>JavaScript</code>引擎内部会记住上一轮循环的值。设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<p><code>let</code>声明的变量一定要在声明后使用，否则报错。</p>
<p><code>ES6</code>明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。（暂时性死区本质：只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。）</p>
<p>不允许重复声明。</p>
<p>原本想实现块级作用域需要立即执行函数表达式，有了新功能用<code>let</code>就可以实现。</p>
<p>应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<p>如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</p>
</li>
<li><p><code>const</code></p>
<p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p><code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<p>只在声明所在的块级作用域内有效。</p>
<p>用<code>const</code>定义的引用类型的数据，只能保证指针不变，但是指向的内存空间的数据结构就不一定了。（可以改指针指向的数据，但是不能改指向的空间）。但是可以使用<code>Object.freeze</code>方法冻结对象以及对象的属性，使得无法对对象的属性做修改。</p>
</li>
<li><p>顶层对象的属性</p>
<p><code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象（<code>window</code>）的属性；<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。</p>
</li>
<li><p><code>globalThis</code>对象</p>
<p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是在不同实现里面是不统一的。</p>
<p>现在规定可以用<code>globalThis</code>对象来取得顶层对象，只想全局环境下的<code>this</code>。</p>
</li>
<li><p><code>...</code>扩展运算符</p>
<p>作用：将一个数组转为用逗号分隔的参数序列。</p>
<p>参考链接：<a href="https://www.cnblogs.com/wangyunhui/p/7511615.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangyunhui/p/7511615.html</a></p>
</li>
<li><p>解构赋值</p>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。</p>
<p>只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/18/ES6one/" data-id="cjyczzu490001gwutxuzncujl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jsNote6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/jsNote6/" class="article-date">
  <time datetime="2019-07-17T14:02:10.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/jsNote6/">jsNote6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="捋一遍思路"><a href="#捋一遍思路" class="headerlink" title="捋一遍思路"></a>捋一遍思路</h4><ul>
<li><p>面向对象的程序设计</p>
<ul>
<li><p>理解属性</p>
<p>数据属性：<code>configurable</code>，<code>enumerable</code>，<code>writable</code>，<code>value</code>。</p>
<p>访问器属性：<code>configurable</code>，<code>enumerable</code>，<code>get</code>，<code>set</code>。</p>
<p>方法：<code>Object.defineProperty()</code>，<code>Object.defineProperties()</code>，<code>Object.getOwnPropertyDescriptor()</code>。</p>
</li>
<li><p>创建对象</p>
<ol>
<li><p>工厂模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">	o.name = name;</span><br><span class="line">	o.age = age;</span><br><span class="line">	o.job = job;</span><br><span class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>好处：可以创造多个相似对象。</p>
<p>缺点：没有解决对象识别的问题。（即没法判断对象的类型）</p>
</li>
<li><p>构造函数模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">	<span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>tip：构造函数始终应该以大写字母开头，而非构造函数则应该以一个小写字母开头。</p>
<p>后面<code>new</code>出来的两个实例都有一个<code>constructor</code>属性，该属性指向<code>Person</code>。</p>
<p>优点：可以检测对象类型。（<code>instanceof</code>）</p>
<p>缺点：每个实例都会创建一个新的相同的方法，无法实现函数复用，浪费内存。</p>
</li>
<li><p>原型模式</p>
<p>我们创建的每个函数都有一个<code>prototype</code>（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享它所包含的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();		<span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();		<span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName);		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>tip：当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。</p>
<p>使用<code>hasOwnPertitype()</code>方法可以检测一个属性是存在于实例中，还是存在于原型中。</p>
<p>可以使用对象字面量来重写整个原型对象，但要记得在这种方式下要指定<code>contructor</code>属性（最好用<code>Object.defineProperty()</code>方法设定）。</p>
<p>好处：可以让所有对象实例共享它包含的属性和方法。</p>
<p>缺点：如果对原型中的引用类型做出修改，修改可能会反映在所有实例上，或许不会是我们想要的结果。</p>
</li>
<li><p>组合模式</p>
<p>实例属性（有可能根据实例不同而不同的属性）在构造函数中定义，由所有实例共享的属性和方法（固定不变的方法和属性）则是在原型中定义的。</p>
<p>这是用来定义引用类型的一种默认模式。</p>
</li>
<li><p>动态原型模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName();</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
</li>
</ul>
<pre><code>   tip：不能使用对象字面量重写原型。

6. 寄生构造函数模式

   基本思想：创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。

   和工厂模式很类似。

7. 稳妥构造函数模式

   稳妥对象：没有公共属性，而且其方法也不引用`this`的对象。</code></pre><ul>
<li><p>继承</p>
<ol>
<li><p>原型链</p>
<p>基本思想：利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subprototype = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SupType</span></span><br><span class="line">SupType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue);		<span class="comment">//true</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ul>
<pre><code>   继承是通过创建`SuperType`的实例，并将该实例赋给`SubType.prototype`实现的。实现的本质是重写原型对象，代之以一个新类型的实例。

   所有函数的默认原型都是`Object`的实例。

   缺点：1.在通过原型来实现继承时，原型实际上会变成另一个类型的实例。于是，原先的实例属性也就顺理成章地变成了现在的原型属性了。 2.在创建子类型的实例时，不能向超类型的构造函数中传递参数。

2. 借用构造函数（伪造对象或经典继承）

   基本思想：在子类型构造函数的内部调用超类型构造函数

   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);	<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors);	<span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>


   优势：可以在子类型构造函数中向超类型构造函数传递参数。</code></pre><p>未完待续。。。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/17/jsNote6/" data-id="cjyczzu51000ggwutdnm1p6dx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-canvasLearning" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/canvasLearning/" class="article-date">
  <time datetime="2019-07-16T13:25:27.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/canvasLearning/">canvasLearning</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="使用-lt-canvas-gt"><a href="#使用-lt-canvas-gt" class="headerlink" title="使用&lt;canvas&gt;"></a>使用<code>&lt;canvas&gt;</code></h3><h4 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h4><ul>
<li><p><code>&lt;canvas&gt;</code>元素本身用<code>width</code>和<code>height</code>来设置宽高，一般不要用CSS来设置这两个属性，因为如果用CSS则有可能在绘制过程中扭曲图像。</p>
</li>
<li><p>如果浏览器不支持这个标签，那么标签里的内容如图片或文字才会作为替换内容显现出来。若支持，则<code>&lt;canvas&gt;</code>和<code>&lt;/canvas&gt;</code>标签之间的内容将会被忽略。所以不能省略结束标签<code>&lt;/canvas&gt;</code>，否则<code>&lt;canvas&gt;</code>标签后面的内容都会被当作替换内容，在支持<code>&lt;canvas&gt;</code>的情况下那些内容都不会显现出来。</p>
</li>
<li><p><code>&lt;canvas&gt;</code>元素公开的一个或多个渲染上下文可以用来绘制和处理要展示的内容。可以使用<code>getContext()</code>方法来获取相应的渲染上下文和它的绘图功能。若要绘制2D图像，则可以传入参数<code>2d</code>，以此来获得绘制2D图像的渲染上下文。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"canvas"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>栅格</p>
<p>在用<code>&lt;canvas&gt;</code>元素创造出来的画布空间里，会有一个默认的坐标网格（栅格），每一像素是一个坐标单位，起点坐标在左上角<code>(0,0)</code>。向右向下是<code>x</code>，<code>y</code>轴的正方向。</p>
</li>
<li><p>绘制矩形的方法</p>
<ul>
<li><p><code>fillRect(x,y,width,height)</code>绘制一个填充的矩形（fill）</p>
</li>
<li><p><code>strokeRect(x,y,width,height)</code>绘制一个矩形的边框（stroke）</p>
</li>
<li><p><code>clearRect(x,y,width,height)</code>清除指定矩形区域，让清除部分完全透明（clear）</p>
<p><code>x</code>，<code>y</code>是坐标，<code>width</code>，<code>height</code> 是矩形的宽高。</p>
</li>
</ul>
</li>
<li><p>绘制路径的方法</p>
<ul>
<li><code>beginPath()</code>新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。</li>
<li><code>closePath()</code>闭合路径之后图形绘制命令又重新指向到上下文中。但图形原本就是闭合的时候，使用这个方法不会有改变。</li>
<li><code>stroke()</code>通过线条来绘制轮廓。</li>
<li><code>fill()</code>通过填充路径的内容区域生成实心的图形。调用这个方法时，没有闭合的图形自动闭合。</li>
</ul>
</li>
<li><p>移动笔触</p>
<p><code>moveTo(x,y)</code>将笔触移动到指定的坐标<code>x</code>以及<code>y</code> 上。</p>
</li>
<li><p>绘制线条</p>
<p>直线：<code>lineTo(x,y)</code>绘制一条从当前位置到指定<code>x</code>以及<code>y</code>位置的直线。</p>
<p>圆弧：</p>
<ol>
<li><p><code>arc(x,y,radius,startAngle,endAngle,anticlockwise)</code></p>
<p>画一个以<code>(x,y)</code>为圆心的以<code>radius</code>为半径的圆弧（圆），从<code>startAngle</code>开始到<code>endAngle</code>结束，按照<code>anticlockwise</code>给定的方向（默认为顺时针）来生成。</p>
<p><code>x,y</code>为绘制圆弧所在圆上的圆心坐标。<code>radius</code>为半径。<code>startAngle</code>以及<code>endAngle</code>参数用弧度定义来开始及结束的弧度，这些都是以<code>x</code>轴为基准。参数<code>anticlockwise</code>为一个布尔值，为<code>true</code>时，是逆时针方向，否则顺时针方向。</p>
</li>
<li><p><code>arcTo(x1,y1,x2,y2,radius)</code>根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。</p>
</li>
</ol>
<p>二次贝塞尔曲线及三次贝塞尔曲线</p>
<p>主要是理解贝塞尔曲线的控制点和起始点结束点</p>
<ul>
<li><code>quadraticCurveTo(cp1x, cp1y, x, y)</code>，绘制二次贝塞尔曲线，<code>cp1x,cp1y</code>为一个控制点，<code>x,y</code>为结束点。</li>
<li><code>bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)</code>，绘制三次贝塞尔曲线，<code>cp1x,cp1y</code>为控制点一，<code>cp2x,cp2y</code>为控制点二，<code>x,y</code>为结束点。</li>
</ul>
</li>
<li><p>矩形</p>
<p><code>rect(x, y, width, height)</code>绘制一个左上角坐标为<code>(x,y)</code>，宽高为<code>width</code>以及<code>height</code>的矩形。</p>
<p>当该方法执行的时候，<code>moveTo()</code>方法自动设置坐标参数<code>(0,0)</code>。也就是说，当前笔触自动重置回默认坐标。</p>
</li>
<li><p><code>Path2D()</code>对象</p>
<p>方便用于保存路径的对象。</p>
</li>
</ul>
<h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><h5 id="上色"><a href="#上色" class="headerlink" title="上色"></a>上色</h5><ul>
<li><p><code>fillStyle = color</code>设置图形的填充颜色。</p>
</li>
<li><p><code>strokeStyle = color</code>设置图形轮廓的颜色。</p>
</li>
<li><p><code>globalAlpha = transparencyValue</code>这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。</p>
<p>tips：<code>color</code>需是有效的符合<code>CSS3颜色值标准</code>的字符串。以上三个值是设置之后绘制的图形的颜色透明度等值，就好像拿画笔画画上的一部分先取色一样，不会对之前画好已经规定好颜色的区域造成影响。</p>
</li>
</ul>
<h5 id="线型（线的样式）"><a href="#线型（线的样式）" class="headerlink" title="线型（线的样式）"></a>线型（线的样式）</h5><ul>
<li><code>lineWidth = value</code>设置线条宽度。属性值必须为正数，默认值是<code>1.0</code>。有时会出现半渲染的情况。</li>
<li><code>lineCap = type</code>设置线条末端样式。有<code>butt(默认)</code>，<code>round</code>，<code>square(端点处加上了等宽且高度为一半线宽的方块)</code>三种取值。</li>
<li><code>lineJoin = type</code>设定线条与线条间接合处的样式。有<code>round(边角处被磨圆了。圆的半径等于线宽)</code>，<code>bevel(交接处是平的)</code>，<code>miter(默认，线段会在连接处外侧延伸直至交于一点)</code>三种取值。</li>
<li><code>miterLimit = value</code>限制当两条线相交时交接处最大长度，所谓交接处长度（斜接长度）是指线条交接处内角顶到外角顶点的长度。如果交点距离大于此值，连接效果会变成<code>bevel</code>。</li>
<li><code>getLineDash()</code>返回一个包含当前虚线样式，长度为非负偶数的数组。</li>
<li><code>setLineDash(segments)</code>设置当前虚线样式。接受一个数组，来指定线段与间隙的交替。</li>
<li><code>lineDashOffset = value</code>设置虚线样式的起始偏移量。</li>
</ul>
<h5 id="渐变Gradients"><a href="#渐变Gradients" class="headerlink" title="渐变Gradients"></a>渐变<code>Gradients</code></h5><ul>
<li><code>createLinearGradient(x1, y1, x2, y2)</code>，<code>(x1,y1)</code> 表示渐变的起点，<code>(x2,y2)</code>表示终点 。</li>
<li><code>createRadialGradient(x1, y1, r1, x2, y2, r2)</code>，前三个参数定义一个以<code>(x1,y1)</code>为原点，半径为<code>r1</code>的起始圆，后三个参数则定义另一个以<code>(x2,y2)</code>为原点，半径为<code>r2</code>的结束圆。</li>
<li><code>gradient.addColorStop(position, color)</code>，<code>position</code>是一个<code>0.0</code>与<code>1.0</code>之间的数值，表示渐变中颜色所在的相对位置。</li>
<li><code>strokeStyle</code>和<code>fillStyle</code>属性都可以接受<code>canvasGradient</code>对象。</li>
</ul>
<h5 id="图案样式"><a href="#图案样式" class="headerlink" title="图案样式"></a>图案样式</h5><ul>
<li><code>createPattern(image, type)</code>，<code>image</code>可以是一个<code>Image</code>对象的引用，或者另一个<code>canvas</code>对象。<code>Type</code>必须是下面的字符串值之一：<code>repeat</code>，<code>repeat-x</code>，<code>repeat-y</code>和<code>no-repeat</code>。</li>
</ul>
<h5 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h5><ul>
<li><code>shadowOffsetX = float</code>阴影在<code>x</code>轴上的延伸距离，正值向右，负值向左，默认值为<code>0</code>。</li>
<li><code>shadowOffsetY = float</code>阴影在<code>y</code>轴上的延伸距离，正值向下，负值向上，默认值为<code>0</code>。</li>
<li><code>shadowBlur = float</code>阴影的模糊程度，默认值为<code>0</code>。</li>
<li><code>shadowColor = color</code>阴影的颜色，标准的CSS颜色值，默认是全透明的黑色。</li>
</ul>
<p>……….知识点太多写不完了，上面主要是在MDN上看的，网址在此：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p>
<ul>
<li><p>后来借助教程的各种知识点，写了一个时钟。下面贴上代码。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>clock<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"400"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">		<span class="built_in">window</span>.onload = draw();</span></span><br><span class="line">		setInterval(draw, 1000);</span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>).getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="javascript">			<span class="comment">//先画出底盘颜色</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line"><span class="javascript">			canvas.arc(<span class="number">200</span>, <span class="number">200</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI*<span class="number">2</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">			canvas.fillStyle = <span class="string">"rgb(94, 124, 152)"</span>;</span></span><br><span class="line">			canvas.fill();</span><br><span class="line"><span class="javascript">			<span class="comment">//画出0，3，6，9刻度线</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line"><span class="javascript">			canvas.lineCap = <span class="string">"round"</span>;</span></span><br><span class="line"><span class="javascript">			canvas.strokeStyle = <span class="string">"#fff"</span>;</span></span><br><span class="line">			canvas.lineWidth = 6;</span><br><span class="line"><span class="javascript">			<span class="comment">//0</span></span></span><br><span class="line">			canvas.moveTo(200, 40);</span><br><span class="line">			canvas.lineTo(200, 60);</span><br><span class="line"><span class="javascript">			<span class="comment">//3</span></span></span><br><span class="line">			canvas.moveTo(200, 360);</span><br><span class="line">			canvas.lineTo(200, 340);</span><br><span class="line"><span class="javascript">			<span class="comment">//6</span></span></span><br><span class="line">			canvas.moveTo(360, 200);</span><br><span class="line">			canvas.lineTo(340, 200);</span><br><span class="line"><span class="javascript">			<span class="comment">//9</span></span></span><br><span class="line">			canvas.moveTo(40, 200);</span><br><span class="line">			canvas.lineTo(60, 200);</span><br><span class="line">			canvas.stroke();</span><br><span class="line"><span class="javascript">			<span class="comment">//画出其他小时刻度线</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">12</span>; i++)&#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(i % <span class="number">3</span> == <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">continue</span>;</span></span><br><span class="line">				&#125;</span><br><span class="line">				canvas.beginPath();</span><br><span class="line">				canvas.lineWidth = 3;</span><br><span class="line"><span class="javascript">				canvas.moveTo(<span class="number">200</span>+<span class="number">160</span>*<span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.PI/<span class="number">6</span> * i), <span class="number">200</span><span class="number">-160</span>*<span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.PI/<span class="number">6</span> * i));</span></span><br><span class="line"><span class="javascript">				canvas.lineTo(<span class="number">200</span>+<span class="number">140</span>*<span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.PI/<span class="number">6</span> * i), <span class="number">200</span><span class="number">-140</span>*<span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.PI/<span class="number">6</span> * i));</span></span><br><span class="line">				canvas.stroke();</span><br><span class="line">			&#125;</span><br><span class="line"><span class="javascript">			<span class="comment">//画出分钟刻度线</span></span></span><br><span class="line"><span class="javascript">			<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">60</span>; i++)&#123;</span></span><br><span class="line"><span class="javascript">				<span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">continue</span>;</span></span><br><span class="line">				&#125;</span><br><span class="line">				canvas.beginPath();</span><br><span class="line">				canvas.lineWidth = 3;</span><br><span class="line"><span class="javascript">				canvas.moveTo(<span class="number">200</span>+<span class="number">160</span>*<span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.PI/<span class="number">30</span> * i), <span class="number">200</span><span class="number">-160</span>*<span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.PI/<span class="number">30</span> * i));</span></span><br><span class="line"><span class="javascript">				canvas.lineTo(<span class="number">200</span>+<span class="number">150</span>*<span class="built_in">Math</span>.sin(<span class="built_in">Math</span>.PI/<span class="number">30</span> * i), <span class="number">200</span><span class="number">-150</span>*<span class="built_in">Math</span>.cos(<span class="built_in">Math</span>.PI/<span class="number">30</span> * i));</span></span><br><span class="line">				canvas.stroke();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> sec = now.getSeconds();</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> min = now.getMinutes();</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> hr = now.getHours();</span></span><br><span class="line">			hr = hr&gt;=12 ? hr-12 : hr;</span><br><span class="line"></span><br><span class="line"><span class="javascript">			<span class="comment">//画出时针</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line">			canvas.moveTo(200, 200);</span><br><span class="line"><span class="javascript">			canvas.strokeStyle = <span class="string">"white"</span>;</span></span><br><span class="line">			canvas.lineWidth = 4;</span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> hrAng = <span class="built_in">Math</span>.PI/<span class="number">6</span>*hr + <span class="built_in">Math</span>.PI/<span class="number">360</span>*min + <span class="built_in">Math</span>.PI/<span class="number">21600</span>*sec;</span></span><br><span class="line"><span class="javascript">			canvas.lineTo(<span class="number">200</span> + <span class="number">90</span>*<span class="built_in">Math</span>.sin(hrAng), <span class="number">200</span> - <span class="number">90</span>*<span class="built_in">Math</span>.cos(hrAng));</span></span><br><span class="line">			canvas.stroke();</span><br><span class="line"></span><br><span class="line"><span class="javascript">			<span class="comment">//画出分针</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line">			canvas.moveTo(200, 200);</span><br><span class="line"><span class="javascript">			canvas.strokeStyle = <span class="string">"white"</span>;</span></span><br><span class="line">			canvas.lineWidth = 3;</span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> minAng = <span class="built_in">Math</span>.PI/<span class="number">30</span>*min + <span class="built_in">Math</span>.PI/<span class="number">1800</span>*sec;</span></span><br><span class="line"><span class="javascript">			canvas.lineTo(<span class="number">200</span> + <span class="number">110</span>*<span class="built_in">Math</span>.sin(minAng), <span class="number">200</span> - <span class="number">110</span>*<span class="built_in">Math</span>.cos(minAng));</span></span><br><span class="line">			canvas.stroke();</span><br><span class="line"></span><br><span class="line"><span class="javascript">			<span class="comment">//画出秒针</span></span></span><br><span class="line">			canvas.beginPath();</span><br><span class="line">			canvas.moveTo(200, 200);</span><br><span class="line"><span class="javascript">			canvas.strokeStyle = <span class="string">"white"</span>;</span></span><br><span class="line">			canvas.lineWidth = 2;</span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> secAng = <span class="built_in">Math</span>.PI/<span class="number">30</span>*sec;</span></span><br><span class="line"><span class="javascript">			canvas.lineTo(<span class="number">200</span> + <span class="number">140</span>*<span class="built_in">Math</span>.sin(secAng), <span class="number">200</span> - <span class="number">140</span>*<span class="built_in">Math</span>.cos(secAng));</span></span><br><span class="line">			canvas.stroke();</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>主要原理是设置一个定时器，每一秒获取当前时间一句即时的时分秒定好时分秒针的角度然后在画布上画出来。我这里每一秒都把整个表盘重新画了一次覆盖在之前的表盘上面，也可以先把表盘画好，用定时器画针就好，但是如果是这个方法的话记得清除之前画的针。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/16/canvasLearning/" data-id="cjyczzu56000kgwutypnonha5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jsNote5" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/15/jsNote5/" class="article-date">
  <time datetime="2019-07-15T13:34:06.000Z" itemprop="datePublished">2019-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/15/jsNote5/">jsNote5</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h4><ul>
<li>闭包是指有权访问另一个函数作用域中的变量的函数。</li>
<li>后台的每个执行环境都有一个表示变量的对象——变量对象。执行环境中定义的所有变量和函数都保存在这个对象里。</li>
<li>作用域链本质上使一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</li>
<li>闭包只能取得包含函数中任何变量的最后一个值。</li>
<li>匿名函数的执行环境具有全局性，因此其<code>this</code>对象通常指向<code>window</code>。</li>
<li>JavaScript中没有私有成员的概念，所有对象属性都是公有的。不管在任何函数中定义的变量，都可以认为是私有变量。有权访问私有变量和私有函数的公有方法称为特权方法。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/15/jsNote5/" data-id="cjyczzu59000mgwutcl887zi1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-随笔" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/14/随笔/" class="article-date">
  <time datetime="2019-07-14T12:26:02.000Z" itemprop="datePublished">2019-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/14/随笔/">随笔</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​        今天是来工作室培训的第七天（算上中间昨天放假）。</p>
<p>​        这个暑假可能是难得的有一整块培训的时间。其实我觉得一个月可能会有点短，但是也觉得该回家一趟。所以下个月还是会回家一段时间，希望回家了也能静得下心来学习吧。</p>
<p>​        这两天一直在看高程，有些地方还是有点绕的，希望能赶紧看完，但是主要还是想理解的透彻一点。在未来的学习生涯我更希望把基础打好，最想培养的是持续学习的能力，感觉其中基础扎实很重要，也才能支持我将来走的更远。</p>
<p>​        每天在这里过的都快乐又愧疚，快乐是觉得氛围真的很好，环境也很舒适，我前两天甚至过上了养生的生活，每天也能有学习的时间。愧疚的是感觉我还不够认真，每天学习的时长好像不够多，但是在规定时间外我真的很难使自己静下心来学习，希望接下来能更好的约束自己吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/14/随笔/" data-id="cjyczzu5f000qgwutssbj1qka" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/life/">life</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jsNote4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/12/jsNote4/" class="article-date">
  <time datetime="2019-07-12T13:38:17.000Z" itemprop="datePublished">2019-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/12/jsNote4/">jsNote4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><code>sort(比较函数)</code>方法的内部原理是冒泡排序。</li>
<li><code>slice()</code>方法包含起始位置的项，不包含结束位置的项。</li>
<li>使用迭代方法注意浏览器是否支持。</li>
<li><code>Date</code>类型保存的日期能够精确到1970年1月1日之前或之后的100,000,000年。</li>
<li>正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新的RegExp实例都是一个新实例。</li>
<li>在正则表达式模式中是否使用g决定了<code>exec()</code>方法能否查找到多个匹配项，若是不使用则将始终返回第一个匹配项的信息，若是使用则每次调用都会在字符串中查找新的匹配信息。</li>
<li>使用不带圆括号的函数名是访问函数指针，而非调用函数。</li>
<li>不要再严格模式下使用<code>callee</code>和<code>caller</code>属性。</li>
<li>在ECMAScript5中，<code>prototype</code>属性是不可枚举的，因此在使用<code>for-in</code>时无法发现。</li>
<li>引用类型和基本包装类型的主要区别就是对象的生存期，使用<code>new</code>操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间。</li>
<li>布尔表达式中的所有对象都会被转换成<code>true</code>。建议不要使用<code>Boolean</code>对象。</li>
<li>数据属性：<code>Configurable</code>，<code>Enumerable</code>，<code>Writable</code>，<code>Value</code>。</li>
<li>一旦把属性定义为不可配置的，就不能再把它变为可配置的了。可以多次调用<code>Object.defineProperty()</code>方法修改同一属性，但在把<code>configurable</code>特性设置为<code>false</code>之后就会有限制了。</li>
<li>在调用<code>Object.defineProperty()</code>方法时，如果不指定，<code>configurable</code>、<code>enumerable</code>和<code>writable</code>特性的默认值都是<code>false</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/12/jsNote4/" data-id="cjyczzu53000igwutxyqjvq18" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jsNote3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/11/jsNote3/" class="article-date">
  <time datetime="2019-07-11T13:21:27.000Z" itemprop="datePublished">2019-07-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/11/jsNote3/">jsNote3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>ECMAScript中不存在块级作用域，因此在循环内部定义的变量也可以在外部访问到。</p>
</li>
<li><p><code>for-in</code>语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (property in expression) statement</span><br></pre></td></tr></table></figure>

<p>一种精确的迭代语句，可以用来枚举对象的属性。</p>
<p>如果表示要迭代的对象的变量值为<code>null</code>或<code>undefined</code>，<code>for-in</code>语句会抛出错误。ECMAScript5更正了这一行为，对这种情况不再抛出错误，而只是不执行循环体。</p>
</li>
<li><p><code>label</code>语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label: statement</span><br></pre></td></tr></table></figure>

<p>使用该语句可以在代码中添加标签，以便将来使用。</p>
<p>加标签的语句一般都要与<code>for</code>语句等循环语句配合使用。、</p>
</li>
<li><p><code>break</code>和<code>continue</code>语句都可以与<code>label</code>语句联合使用，比如可以使用标签一次跳出多层的嵌套循环。</p>
</li>
<li><p><code>with</code>语句的作用是将代码的作用域设置到一个特定的对象中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">with (expression) statement</span><br></pre></td></tr></table></figure>

<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var qs = location.search.substring(1);</span><br><span class="line">var hostName = location.hostName;</span><br><span class="line">var url = location.href;</span><br></pre></td></tr></table></figure>

<p>可以改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with(location)&#123;</span><br><span class="line">	var qs = search.substring(1);</span><br><span class="line">	var hostName = hostName;</span><br><span class="line">	var url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>严格模式下不允许使用<code>with</code>语句，否则将视为语法错误。也不建议使用这个语句。</p>
</li>
<li><p>使用<code>switch</code>语句时记得加<code>break;</code>。可以在<code>switch</code> 语句中使用任何数据类型。该语句在比较值的时候使用的是全等操作符，因此不会发生类型转换。</p>
</li>
<li><p>ECMAScript中的参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）</p>
<p><code>arguments</code>对象只能在函数中使用。</p>
<p><code>arguments</code>的值永远与对应命名参数的值保持同步。但它们的内存空间是独立的。</p>
</li>
<li><p>函数不能重载。</p>
</li>
<li><p>基本类型—-&gt;栈，引用类型—-&gt;堆</p>
</li>
<li><p>函数的参数都是按值传递的，即使是引用类型也是传递了指针的值进去。相当于复制了实参的值给形参，函数内部改变的只是形参的值。但当传递引用类型的值进函数时，对形参的操作可能会影响到传进去的那个实参，是因为形参和实参指向的都是堆中的同一个地址。函数内对形参的操作实际上就是在对堆里面那块内存动手脚。</p>
</li>
<li><p><code>instanceof()</code>用来检测对象的类型。</p>
<p>语法：<code>result = variable instanceof constructor</code></p>
</li>
<li><p>所有引用类型的值都是Object的实例。</p>
</li>
<li><p>每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。</p>
</li>
<li><p>当代码在一个环境中执行时，会创建变量对象的一个作用域链。用途是保证对执行环境有权访问的所有变量和函数的有序访问。内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。</p>
</li>
<li><p>使用<code>var</code>声明的变量会自动被添加到最接近的环境中。如果初始化变量是没有使用<code>var</code>声明，该变量会自动添加到全局环境。</p>
</li>
<li><p>如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符。</p>
</li>
<li><p>引用计数的垃圾清除算法可能会出现循环引用，无法释放内存。</p>
</li>
<li><p>只要在IE中涉及COM对象，就会存在循环引用的问题。IE9将BOM和DOM对象转化成立真正的JavaScript对象，避免了两种垃圾收集算法并存导致的问题。</p>
</li>
<li><p>浏览器的垃圾收集器是周期性运行的，触发机制不同浏览器可能会有差异。在IE中可以用<code>window.CollectGarbage()</code>是垃圾收集立刻执行，在Opera7及更高版本中，调用<code>window.opera.collect()</code>也可以启动垃圾收集例程。但不建议程序员主动触发垃圾收集过程。</p>
</li>
<li><p>一旦数据不再有用，最好通过将其值设置为<code>null</code>来释放其引用，这个做法叫做解除引用。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。适用于大多数全局变量和全局对象的属性。为执行中的代码只保存必要的数据是优化内存占用的最佳方式。</p>
</li>
<li><p>表达式上下文指的是该上下文期待一个值（表达式）。</p>
</li>
<li><p>在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号内。</p>
</li>
<li><p><code>join()</code>方法可以指定数组元素输出为字符串时的分隔符。</p>
</li>
<li><p>数组的<code>pop()</code>方法返回的是取得的值，<code>push()</code>方法返回的数组长度。</p>
</li>
<li><p>用<code>shift()</code>和<code>push()</code>方法可以实现类似于队列先进先出的数据结构。<code>unshift()</code>和<code>pop()</code>可以实现与队列相反的操作，队头进，队尾出。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/11/jsNote3/" data-id="cjyczzu5b000ogwut38d0wf61" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-jsNote2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/jsNote2/" class="article-date">
  <time datetime="2019-07-10T13:43:30.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/jsNote2/">jsNote2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>虽然JavaScript中可以不用分号来结尾（由解析器确定语句的结尾），但是建议任何时候都不要省略分号在语句结束处。好处是增加代码可读性、可以删去不必要的空格来节约空间、增进代码的性能（节约解析器推测语句结尾的时间）</p>
</li>
<li><p>关键字和保留字（将来有可能被用作关键字）不能用作标识符。</p>
<p>在实现ECMAScript3的JavaScript引擎中如果使用关键字作为标识符，会导致<code>&quot;Identifier Expected&quot;</code>错误。而使用保留字作标识符可能会也可能不会导致相同的错误，具体取决于特定的引擎。</p>
</li>
<li><p>变量定义后若还未赋值，则会保存一个特殊的值<code>undefined</code>。</p>
</li>
<li><p>用<code>var</code>定义的变量将成为定义该变量的作用域中的局部变量。即如果在函数中用<code>var</code>定义了变量，该变量在函数退出后就会被销毁。如果省略<code>var</code>操作符，则可以之间创建一个全局变量，在函数退出后该变量依旧有效。</p>
<p>要注意的是，要先让创建全局变量所在的函数中执行过一次后该变量才会生效，否则变量为未定义。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    message = &quot;hi&quot;;		//全局变量</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line">alert(message);			//&quot;hi&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function test()&#123;</span><br><span class="line">    message = &quot;hi&quot;;		//全局变量</span><br><span class="line">&#125;</span><br><span class="line">alert(message);			//Uncaught ReferenceError: message is not defined</span><br></pre></td></tr></table></figure>

<p>可以看到在第二个例子中<code>alert</code>函数处报错了，因为在<code>alert</code>函数使用<code>message</code>前，<code>test</code>函数还未执行过，就是说<code>message = &quot;hi&quot;;</code>还未执行过，相当于<code>message</code>还未定义。</p>
</li>
<li><p>如果一个值是<code>null</code>，使用<code>typeof</code>操作符返回的结果也会是<code>object</code>。因为特殊值<code>null</code>被认为是一个空的对象引用（空对象指针）。</p>
<p>Safari 5及之前版本、Chrome 7及之前版本在对正则表达式调用<code>typeof</code>操作符是会返回<code>&quot;function&quot;</code>，而其他浏览器在这种情况下会返回<code>&quot;object&quot;</code>。</p>
</li>
<li><p>对于尚未声明的变量只能进行一项操作，即使用<code>typeof</code>操作符检测其数据类型，返回<code>&quot;undefined&quot;</code>。</p>
</li>
<li><p>如果定义的变量准备在将来用于保存对象，最好将该变量初始化为<code>null</code>而不是其他值。</p>
</li>
<li><p>严格模式下不支持八进制字面量。</p>
</li>
<li><p>ECMAScript会自动将本身表示的就是一个整数的浮点数比如<code>1.0</code>、<code>1.</code>作为整数保存以节约空间。也会将小数点后面带有6个零以上的浮点数值转换为以e表示法表示的数值。</p>
</li>
<li><p>永远不要测试某个特定的浮点数值，因为基于IEEE754数值的浮点计算会由舍入误差。</p>
</li>
<li><p>如果一个数的数值超出了JavaScript的数值范围，那么这个数值会被自动转换成<code>(-)Infinity</code>表示正（负）无穷。<code>Infinity</code>不是能够参与计算的值。可以使用<code>isFinite()</code>函数来确定一个数值是不是有穷的。这个函数在参数位于最小和最大数值之间时会返回<code>true</code>。</p>
</li>
<li><p><code>NaN</code>表示一个本来要返回数值的操作数未返回数值的情况。</p>
<p>任何涉及<code>NaN</code>的操作都会返回<code>NaN</code>。</p>
<p><code>NaN</code>与任何值都不相等包括它本身，可用<code>isNaN</code>函数来判断一个值是不是<code>NaN</code>。函数在接收到一个值后，会尝试将这个值转换为数值，某些不是数值的数也可以转换为数值比如字符串<code>&quot;10&quot;</code>。任何不能转换为数值的值都会导致这个函数返回<code>true</code>。</p>
</li>
<li><p><code>toString()</code>方法和<code>String()</code>函数的区别</p>
</li>
<li><p><code>toString()</code>方法和<code>toLocaleString()</code>方法的区别</p>
</li>
<li><p><code>toString()</code>方法和<code>valueOf()</code>方法的区别</p>
</li>
<li><p>一元加操作符会像<code>Number()</code>转型函数一样对值进行数值转换。</p>
</li>
<li><p>按位非<code>~</code>操作的本质：操作数的负值减1。</p>
</li>
<li><p>左移<code>&lt;&lt;</code>和右移<code>&gt;&gt;</code>不会影响操作数的符号位。无符号右移<code>&gt;&gt;&gt;</code>会连带符号位一起移动。</p>
</li>
<li><p>逻辑与（或）操作不一定返回布尔值，不能在逻辑与（或）操作中使用未定义的值（但如果发生短路操作且未定义的值是第二个操作数，则不会报错）。逻辑与（或）属于短路操作，如果第一个值是<code>false</code>（<code>true</code>），则不会再对第二个操作数进行求值。</p>
</li>
<li><p>如果要按字母表顺序比较字符串，就必须把两个操作数转换为相同的大小写形式，再执行比较。如使用<code>toLowerCase()</code>方法。</p>
</li>
<li><p>在比较数字和字符串的时候，字符串都会被转换成数值，然后再以数值方式与另一个数值比较。任何数值和<code>NaN</code>进行关系比较，结果都是<code>false</code>。</p>
</li>
<li><p>相等操作符在比较之前进行转换，全等操作度在比较之前不对操作数进行转换。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/10/jsNote2/" data-id="cjyczzu4z000egwut14uj9ogk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScriptLearning/">JavaScriptLearning</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/foot/">foot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">life</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ES6/" style="font-size: 15px;">ES6</a> <a href="/tags/JavaScriptLearning/" style="font-size: 20px;">JavaScriptLearning</a> <a href="/tags/foot/" style="font-size: 10px;">foot</a> <a href="/tags/life/" style="font-size: 10px;">life</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/21/ES6three/">ES6three</a>
          </li>
        
          <li>
            <a href="/2019/07/19/ES6two/">ES6two</a>
          </li>
        
          <li>
            <a href="/2019/07/18/ES6one/">ES6one</a>
          </li>
        
          <li>
            <a href="/2019/07/17/jsNote6/">jsNote6</a>
          </li>
        
          <li>
            <a href="/2019/07/16/canvasLearning/">canvasLearning</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>